<?xml version="1.0" encoding="UTF-8"?>

<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="messagecollection.xsd">
  <!--
  **********************************************************************
  插件信息
  **********************************************************************
  -->
  <Plugin>
    <ShortDescription> 核心的 FindBugs 插件 </ShortDescription>
    <Details>
<![CDATA[
<p>
这个插件包含所有标准的 FindBugs 的检测器。
</p>
]]>
    </Details>
    <BugsUrl>http://findbugs.sourceforge.net/bugDescriptions.html</BugsUrl>
    <AllBugsUrl>http://findbugs.sourceforge.net/allBugDescriptions.html</AllBugsUrl>
  </Plugin>
  <FindBugsMain cmd="addMessages" class="edu.umd.cs.findbugs.AddMessages">
    <Description>输入添加msgs（eg 错误的文本描述）来分析结果</Description>
  </FindBugsMain>
  <FindBugsMain cmd="analyze" class="edu.umd.cs.findbugs.FindBugs2">
    <Description>执行FindBugs分析</Description>
  </FindBugsMain>
  <FindBugsMain cmd="gui" class="edu.umd.cs.findbugs.gui2.Driver">
    <Description>运行 FindBugs GUI</Description>
  </FindBugsMain>
  <FindBugsMain cmd="list" class="edu.umd.cs.findbugs.PrintingBugReporter">
    <Description>将分析结果转换为文本形式</Description>
  </FindBugsMain>
  <FindBugsMain cmd="help" class="edu.umd.cs.findbugs.ShowHelp">
    <Description>为指令提供帮助</Description>
  </FindBugsMain>
  <FindBugsMain cmd="version" class="edu.umd.cs.findbugs.Version">
    <Description>列出FindBugs的版本</Description>
  </FindBugsMain>
  <FindBugsMain cmd="filter" class="edu.umd.cs.findbugs.workflow.Filter">
    <Description>过滤分析结果</Description>
  </FindBugsMain>
  <FindBugsMain cmd="set" class="edu.umd.cs.findbugs.workflow.SetBugDatabaseInfo">
    <Description>设置项目配置/选项</Description>
  </FindBugsMain>
  <FindBugsMain cmd="history" class="edu.umd.cs.findbugs.workflow.MineBugHistory">
    <Description>列出多版本的分析结果的详细信息</Description>
  </FindBugsMain>
  <FindBugsMain cmd="union" class="edu.umd.cs.findbugs.workflow.UnionResults">
    <Description>合并来自不相交组件的分析结果</Description>
  </FindBugsMain>
  <FindBugsMain cmd="merge" class="edu.umd.cs.findbugs.workflow.Update">
    <Description>将来自不同软件版本的分析结果结合，以生成多版本分析结果</Description>
  </FindBugsMain>

  <FindBugsMain cmd="dis" class="edu.umd.cs.findbugs.workflow.PrintClass">
    <Description>反汇编一个类文件</Description>
  </FindBugsMain>
  <FindBugsMain cmd="errors" class="edu.umd.cs.findbugs.workflowListErrors">
    <Description>列出在结果文件中储存的分析错误</Description>
  </FindBugsMain>

  <!-- On changing this, please also update default cloud id in FindbugsPlugin -->
  <Cloud id="edu.umd.cs.findbugs.cloud.doNothingCloud">
    <Description>(云禁用)</Description>
    <Details>使用此插件时，将禁用进行bug的复核。</Details>
  </Cloud>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMultithreaded">
    <Description>抑制多线程正确性问题</Description>
    <Details>抑制所有多线程正确性问题</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressI18N">
    <Description>抑制国际化问题</Description>
    <Details>抑制所有国际化问题</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SelectivelySuppressI18N">
    <Description>除了选定的软件包之外，其他所有国际化问题都要解决</Description>
    <Details>抑制除了在 i18n.properties 资源中指定的 其它所有国际化问题</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.MaxRank14">
    <Description>抑制排名高于14的所有问题</Description>
    <Details>抑制排名高于14的所有问题</Details>
  </PluginComponent>
  <PluginComponent id="edu.umd.cs.findbugs.bugReporter.SuppressMalicious">
    <Description>禁止有关恶意代码漏洞的警告</Description>
    <Details>禁止有关恶意代码漏洞的警告</Details>
  </PluginComponent>
  <!--
  **********************************************************************
  类别（替换 BugCategoryDescriptions.properties 的文件）
  **********************************************************************
   -->
  <BugCategory category="CORRECTNESS">
    <Description>准确性</Description>
    <Abbreviation>C</Abbreviation>
    <Details>可能的错误 - 明显的编码错误导致得到的代码可能不是开发人员想要表达的。
            我们努力争取低误报率。</Details>
  </BugCategory>
  <BugCategory category="NOISE">
    <Description>伪造的随机杂音</Description>
    <Abbreviation>N</Abbreviation>
    <Details>伪造的随机杂音: 旨在作为数据挖掘实验中的控件起到作用，而不是在软件中查找实际错误
            </Details>
  </BugCategory>
  <BugCategory category="SECURITY">
    <Description>安全</Description>
    <Abbreviation>S</Abbreviation>
    <Details>使用不被信任的输入方式可以在某种程度上创造一个可远程利用的安全漏洞。</Details>
  </BugCategory>
  <BugCategory category="BAD_PRACTICE">
    <Description>不好的做法</Description>
    <Abbreviation>B</Abbreviation>
    <Details>违规于推荐的和必要的编码实践
            例子包括： hash代码 和 相等问题， 可复制的习语，丢弃的异常，可序列化的问题，以及最终化的误用。
            我们尽力使这个分析准确化，虽然有些团体和组织可能不介意一些错误的编码习惯</Details>
  </BugCategory>
  <BugCategory category="STYLE">
    <Description>Dodgy code</Description>
    <Abbreviation>D</Abbreviation>
    <Details>那些混乱、异常或者以会导致错误方式编写的代码。
            例子包括：死机的本地储存，交换机掉落，未被确认的强制转换，以及多余的对已知为空的值的空值检验。
            更多的误报被接受
            在以前版本的FindBugs中，此类别称为Style。
</Details>
  </BugCategory>
  <BugCategory category="PERFORMANCE">
    <Description>性能</Description>
    <Abbreviation>P</Abbreviation>
    <Details>代码不一定不正确但是可能效率很低</Details>
  </BugCategory>
  <BugCategory category="MALICIOUS_CODE">
    <Description>恶意代码漏洞</Description>
    <Abbreviation>V</Abbreviation>
    <Details>那些易受不信任代码攻击的代码</Details>
  </BugCategory>
  <BugCategory category="MT_CORRECTNESS">
    <Description>多线程地确认工作</Description>
    <Abbreviation>M</Abbreviation>
    <Details>代码缺陷与线程（threads），锁(locks)和挥发物(volatiles)有关</Details>
  </BugCategory>
  <BugCategory category="I18N">
    <Description>国际化</Description>
    <Abbreviation>I</Abbreviation>
    <Details>代码缺陷与国际化和区域设置有关</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>
  <BugCategory category="EXPERIMENTAL">
    <Description>试验</Description>
    <Abbreviation>X</Abbreviation>
    <Details>实验的和并非完全审查的bug模式</Details>
    <!-- DM_CONVERT_CASE is the only core bug pattern in this category -->
  </BugCategory>
  <!--
  **********************************************************************
  探测器
  **********************************************************************
   -->
  <Detector class="edu.umd.cs.findbugs.detect.FindRoughConstants">
    <Details>
<![CDATA[
<p> 查找大致（但不精确）等于Math.PI等已知值的常量。
</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializeNonnullFieldsInConstructor">
    <Details>
<![CDATA[
<p> 查找未在构造函数中写入的非空字段。
</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IntCast2LongAsInstant">
    <Details>
<![CDATA[
<p> 查找 32位值 来描述自纪元以来的毫秒数。
</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainLongInstantfParams">
    <Details>
<![CDATA[
<p> 构建采用 64位值 来描述自纪元以来的毫秒数的 参数数据库。</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InconsistentAnnotations">
    <Details>
<![CDATA[
<p> 这个检测器会找到类型限定符之间 直接应用于方法参数和方法参数使用的 不一致性。</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AtomicityProblem">
    <Details>
<![CDATA[
<p> 在一个不会以原子化方式执行的并发抽象上查找操作序列（例如 get/put）
    </p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizationOnSharedBuiltinConstant">
    <Details>
<![CDATA[
<p> 此检测器在共享内置常量（例如String）上查找同步。</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeAndNullCheckField">
    <Details>
<![CDATA[
<p> 此检测器查找已同步的字段，然后检查空值。</p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckImmutableAnnotation">
    <Details>
<![CDATA[
<p> 查找违反了类似于net.jcip.annotations.Immutable or javax.annotation.concurrent.Immutable.等注释的类的规则的违规行为</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VarArgsProblems">
    <Details>
<![CDATA[
<p> 查找Java 1.5 var args引起的问题。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteJCIPAnnotation">
    <Details>
<![CDATA[
<p> 记录在net.jcip.annotations包中的注释。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteDirectlyRelevantTypeQualifiers">
    <Details>
<![CDATA[
<p> 请注意与分析方法相关的类型限定符。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildInterproceduralCallGraph">
    <Details>
      <![CDATA[
      <p>构建过程调用图。</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildObligationPolicyDatabase">
    <Details>
          <![CDATA[
          <p>构建FindUnsatisfiedObligation检测器 使用的义务类型和方法的数据库。
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSuppressedWarnings">
    <Details>
<![CDATA[
<p> 禁止那些建立在edu.umd.cs.findbugs.annotations.NoteSuppressWarnings 注释上的警告</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteAnnotationRetention">
    <Details>
<![CDATA[
<p> 记录注释保留。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteSyntheticElements">
    <Details>
      <![CDATA[
        <p>记录合成类，方法，字段等。</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Methods">
    <Details>
<![CDATA[
<p> 通过其它探测器来构建一个数据库，涵盖所有在分析类中已经定义了的所有方法 以供使用。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReflectiveClasses">
    <Details>
<![CDATA[

<p> 尝试确定哪些类具有对其.class ogjects.有常量引用。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CalledMethods">
    <Details>
<![CDATA[
<p> 构建分析类中调用的所有方法的数据库，供其他检测器使用。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNoSideEffectMethods">
    <Details>
<![CDATA[
<p> 寻找没有副作用的方法，只返回一些值。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BuildStringPassthruGraph">
    <Details>
<![CDATA[
<p> 构建不变的 从方法传递给方法 的字符串参数数据库。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FunctionsThatMightBeMistakenForProcedures">
    <Details>
<![CDATA[
<p> 使用返回该类的新实例的方法查找不可变类，人们可能会意外地认为这些方法会改变它们被调用的实例。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusionBetweenInheritedAndOuterMethod">
    <Details>
<![CDATA[
<p> 寻找继承和外部方法之间的潜在混淆。</p>
]]>
    </Details>
  </Detector>
    <Detector class="edu.umd.cs.findbugs.detect.NoteCheckReturnValueAnnotations">
    <Details>
<![CDATA[
<p> 查找注释以检查方法的返回值。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizeOnClassLiteralNotGetClass">
    <Details>
      <![CDATA[
<p> 查找在getClass的结果上相同而不是类文字上同步的代码。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FieldItemSummary">
    <Details>
      <![CDATA[
      <p>
    该检测器会生成 存储在字段中的 摘要信息。
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonNullAnnotations">
    <Details>
      <![CDATA[
      <p>
      在方法、字段和参数上查找@Nonnull注释。
      这些能在  当在仅能使用非空值的上下文中使用可能为空的值时 ，
      被FindNullDeref检测器用来生成警告
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteUnconditionalParamDerefs">
    <Details>
      <![CDATA[
      <p>
      分析应用程序中的所有方法以确定哪些无条件地解除了引用参数。  
      这个信息被用于
      稍后的分析传递以查找可以将空值传递给这些方法的调用站点。
      </p>
      <p>
      This is a slow detector.
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoteNonnullReturnValues">
    <Details>
      <![CDATA[
      <p>
      分析应用程序中的所有方法 以确定哪些方法始终返回非空值。
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BooleanReturnNull">
    <Details>
<![CDATA[
<p> 查找具有返回显式空值的布尔返回类型的方法。</p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OptionalReturnNull">
    <Details>
<![CDATA[
<p> 查找那些返回显示空值的的Optional返回类型的方法</p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessObjects">
    <Details>
<![CDATA[
<p> 寻找无用的对象。</p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableEnum">
    <Details>
          <![CDATA[
<p> 查看并警告可变枚举字段。</p>
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadUseOfReturnValue">
    <Details>
<![CDATA[
<p> 在检查非null之后 查找丢弃函数返回值的情况  </p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InheritanceUnsafeGetResource">
    <Details>
<![CDATA[
<p> 寻找this.getClass().getResource(...)的用法
    这样如果类被另一个包中的类扩展
    可以意外的结果。 </p>

]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteRecursiveLoop">
    <Details>
<![CDATA[
<p> 寻找无限递归循环。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InfiniteLoop">
    <Details>
<![CDATA[
<p> 寻找无限循环。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.VolatileUsage">
    <Details>
<![CDATA[
<p> 在volatile字段的使用中查找错误模式。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EmptyZipFileEntry">
    <Details>
<![CDATA[
<p> 这将查找空zip文件条目的创建。 它是一种适中的快速探测器。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UncallableMethodOfAnonymousClass">
    <Details>
<![CDATA[
<p> 此检测器查找匿名内部类，这些内部类定义可能旨在但不覆盖超类中的方法的方法。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontUseEnum">
    <Details>
<![CDATA[
<p>检查字段和方法是否使用名称assert或enum，因为它们是Java 5中的关键字。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.URLProblems">
    <Details>
<![CDATA[
<p> equals 和 hashCode 的方法 能在<code>java.net.URL</code>上 解析域名。
    因此，这些操作可能非常昂贵，并且此检测器会查找可能调用这些方法的位置。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FinalizerNullsFields">
    <Details>
<![CDATA[
<p> 此检测器查找将类的字段置空的终结器。
这对垃圾收集器没有任何帮助，对字段的清空无效。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CrossSiteScripting">
    <Details>
<![CDATA[
<p> 此检测器查找明显的跨站点脚本漏洞案例。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RepeatedConditionals">
    <Details>
<![CDATA[
<p> 该检测器会查找包含重复条件测试的代码, 例如 (x == 5 || x == 5).
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantConditions">
    <Details>
<![CDATA[
<p> 该检测器会查找包含无用条件的代码  例如这个例子里的第二个条件: (x >= 10 && x >= 5).
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CallToUnsupportedMethod">
    <Details>
<![CDATA[
<p> 此检测器查找对不受支持的方法的调用。
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FormatStringChecker">
    <Details>
<![CDATA[
<p> 检查格式字符串是否错误。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqualsOperandShouldHaveClassCompatibleWithThis">
    <Details>
<![CDATA[
<p>检查equals方法，检查它们的操作数是否是与定义equals方法的类不兼容的类的实例。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround">
    <Details>
<![CDATA[
<p> 该探测器只是用于测试新探测器的钩子（hook）。
通常，这个探测器什么都不做。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[
<p> 该探测器只是用于测试新探测器的钩子（hook）。
通常，这个探测器什么都不做。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LostLoggerDueToWeakReference">
    <Details>
<![CDATA[
<p> 此检测器会找到在OpenJDK 1.6下行为表现不同的代码，其中弱引用用于保持Loggers。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestingGround2">
    <Details>
<![CDATA[
<p> 该探测器只是用于测试新探测器的钩子（hook）。
通常，这个探测器什么都不做。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Noise">
    <Details>
<![CDATA[
<p> 此检测器生成随机信号：警告仅基于方法执行的操作的哈希值。
这些警告是伪随机噪声，旨在用作数据挖掘实验中的控件，而不是在软件中查找实际的错误

该探测器只是用于测试新探测器的钩子。
通常，这个探测器什么都不做。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NoiseNullDeref">
    <Details>
<![CDATA[
<p> 用于空取消引用的噪声检测器。 
    旨在用作关于警告的有效性或预测能力的实验中的控件，而不是用于在代码中发现问题的方式。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.HugeSharedStringConstants">
    <Details>
<![CDATA[
<p> 此检测器查找在多个类文件中重复的字符串常量。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DoInsideDoPrivileged">
    <Details>
<![CDATA[
<p> 查找应在 doPrivileged 模块中执行的代码。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ResolveAllReferences">
    <Details>
<![CDATA[
<p> 检查是否已解决所有引用调用。  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SwitchFallthrough">
    <Details>
<![CDATA[
<p> 此检测器查找 包含了fall through的 switch语句。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFieldSelfAssignment">
    <Details>
<![CDATA[
<p>该检测器通过读取相同字段的值来查找分配字段的位置。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison">
    <Details>
<![CDATA[
<p> 该检测器查找值与自身进行比较的位置。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSelfComparison2">
    <Details>
<![CDATA[
<p> 该检测器查找值与自身进行比较的位置。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonShortCircuit">
    <Details>
<![CDATA[
<p> 该探测器寻找 非短路的可疑用途的 布尔运算符
是(<code>|</code> 和 <code>&amp;</code> 
而不是<code>||</code> 和 <code>&amp;&amp;</code>).</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontCatchIllegalMonitorStateException">
    <Details>
<![CDATA[
<p> 此检测器查找捕获IllegalMonitorStateException的try-catch块。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatMath">
    <Details>
<![CDATA[
<p> 该探测器寻找浮点数学的用途。 它是一种适中的快速探测器。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CloneIdiom">
    <Details>
<![CDATA[
<p> 该检测器查找违反用于编写可克隆类的习语。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ComparatorIdiom">
    <Details>
<![CDATA[
<p> 此检测器查找违反用于编写实现<code> Comparator </ code>的类的习语。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DroppedException">
    <Details>
<![CDATA[
<p> 此检测器查找捕获异常的代码，但不执行任何操作来处理异常。  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LoadOfKnownNullValue">
    <Details>
<![CDATA[
<p> 查找已知为null的值的加载。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethodInvocations">
    <Details>
<![CDATA[
<p> 此检测器查找传递给方法的错误参数(例如., substring(0)).
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DumbMethods">
    <Details>
<![CDATA[
<p> 该探测器寻找无意义方法的调用，
    例如无参数的String构造函数。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CovariantArrayAssignment">
    <Details>
<![CDATA[
<p> 此检测器查找协变数组赋值，如Object [] array = new String [10]，这可能会在运行时导致 ArrayStoreException。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.NumberConstructor">
    <Details>
<![CDATA[
<p> 查找具有原始参数的Number构造函数的调用。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDoubleCheck">
    <Details>
<![CDATA[
<p> 该检测器查找双重检查锁定的实例。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFinalizeInvocations">
    <Details>
<![CDATA[
<p> 此检测器查找对finalize（）和其他终结器相关问题的调用。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindHEmismatch">
    <Details>
<![CDATA[
<p> 此检测器在hashCode（）和equals（）方法的定义中查找问题。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.OverridingEqualsNotSymmetrical">
    <Details>
<![CDATA[
<p> 查找那些在 超类中重写equals方法的 equals方法，其中等价关系可能不对称。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNakedNotify">
    <Details>
<![CDATA[
<p> 此检测器查找对notify（）的调用，这些调用似乎不会修改可变对象状态。  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindReturnRef">
    <Details>
<![CDATA[
<p> 此检测器查找返回可变静态数据的方法。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRunInvocations">
    <Details>
<![CDATA[
<p> 此检测器查找对Thread.run（）的调用  它是一个快速探测器.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSpinLoop">
    <Details>
<![CDATA[
<p> 该探测器寻找从场中旋转读取的循环。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindTwoLockWait">
    <Details>
<![CDATA[
<p> 此检测器查找持有两个（或更多）锁的wait（）调用。
    这是一个慢速探测器。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnconditionalWait">
    <Details>
<![CDATA[
<p> 此检测器查找不在条件或循环中的wait（）调用。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUninitializedGet">
    <Details>
<![CDATA[
<p> 此检测器查找构造函数中未初始化字段的读取。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsyncGet">
    <Details>
<![CDATA[
<p> 此检测器查找get和set方法，
    其中get在 set同步时 不同步。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InitializationChain">
    <Details>
<![CDATA[
<p> 此检测器查找潜在的循环类初始化依赖项。  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IteratorIdioms">
    <Details>
<![CDATA[
<p> 此迭代器查找如何定义Iterator类的问题。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LockedFields">
    <Details>
<![CDATA[
<p> 该检测器查找以 锁定方式不一致 的方式访问的字段。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.EqStringTest">
    <Details>
<![CDATA[
<p> 此检测器使用==或！=运算符查找String对象的比较。
 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableLock">
    <Details>
<![CDATA[
<p> 此检测器查找从修改字段读取的对象的同步。  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SynchronizingOnContentsOfFieldToProtectField">
    <Details>
<![CDATA[
<p> 该检测器查找似乎在字段上同步的代码，以保护该字段的更新。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MutableStaticFields">
    <Details>
<![CDATA[
<p> 此检测器查找可能被恶意代码修改的静态字段。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.Naming">
    <Details>
<![CDATA[
<p> 该探测器寻找可疑名称的方法。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked">
    <Details>
<![CDATA[
<p> 此检测器查找对InputStream.read（）或InputStream.skip（）的调用，其中忽略返回值。  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom">
    <Details>
<![CDATA[
<p>此检测器查找Serializable类的实现中的潜在问题。  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor">
    <Details>
<![CDATA[
<p> 此检测器查找启动线程的构造函数。  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadForLoop">
    <Details>
<![CDATA[
<p> 此检测器查找不正确的循环。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ExplicitSerialization">
    <Details>
<![CDATA[
<p> 通过readObject和writeObject查找显式序列化，作为此类确实是序列化的证据。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnreadFields">
    <Details>
<![CDATA[
<p> 这个探测器寻找那些值还从未被读取的区域  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WaitInLoop">
    <Details>
<![CDATA[
<p> 这个探测器寻找那些不在循环里的wait()引用。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BCPMethodReturnCheck">
    <Details>
<![CDATA[
<p> 这个检测器寻找那些返回值被怀疑并忽视了的方法引用。
    这是一个慢速探测器。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindComparatorProblems">
    <Details>
<![CDATA[
<p>此检测器在Comparator.compare或Comparable.compareTo运行中查找问题。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDeref">
    <Details>
<![CDATA[
<p>此检测器查找可能发生空指针异常的位置。 它还寻找参考值与null的冗余比较。 这是一个慢速探测器。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNullDerefsInvolvingNonShortCircuitEvaluation">
    <Details>
<![CDATA[
<p>此检测器查找可能发生空指针异常的位置，并且使用非短路评估会导致普通技术的失败。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindOpenStream">
    <Details>
<![CDATA[
<p> 此检测器查找IO流对象，这些对象不会从该方法中转义，并且在该方法之外的所有路径上似乎都不会关闭。
这是一个慢速探测器。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PreferZeroLengthArrays">
    <Details>
<![CDATA[
<p> 此检测器查找返回数组或显式空引用的方法。
在此上下文中返回零长度数组通常优选返回空引用。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow">
    <Details>
<![CDATA[
<p> 该检测器查找无效的控制流语句。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
    <Details>
<![CDATA[
<p> 这个探测器会寻找 被需要的但是未在该方法的路径上发布的  JSR-166 (<code>java.util.concurrent</code>)的 锁（locks）
    它是一个中等速度的探测器。
    请注意，为了使用此检测器，您需要在辅助类路径中包含<code> java.util.concurrent </ code>包（或者分析包本身）。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
    <Details>
<![CDATA[
<p> 此检测器查找将两个引用值与==或！=运算符进行比较的位置，并且该类是一个类型（例如<code> java.lang.String </ code>）
    比较参考值通常是一个错误。 
    这是一个慢速探测器。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify">
    <Details>
<![CDATA[
<p> 此检测器查找对wait（），notify（）或notifyAll（）的调用，
    这些调用似乎不是对当前锁定的对象进行的。
    它是一个中等速度的探测器。 <b>此检测器已禁用，因为它仍在开发中，并产生过多的误报。</b></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindEmptySynchronizedBlock">
    <Details>
<![CDATA[
<p> 这个探测器寻找空的同步块</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindInconsistentSync2">
    <Details>
<![CDATA[
<p> 该检测器查找以锁定方式不一致的方式访问的字段。 这是一个慢速探测器。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindLocalSelfAssignment2">
    <Details>
<![CDATA[
<p> 该检测器寻找局部变量的自我分配。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IncompatMask">
    <Details>
<![CDATA[
<p> 该检测器查找可疑的按位逻辑表达式。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.LazyInit">
    <Details>
<![CDATA[
<p> 此检测器查找非易失性字段的惰性字段初始化。它是一个中等速度的检测器。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindJSR166LockMonitorenter">
    <Details>
<![CDATA[
<p> 此检测器查找对JSR166锁执行的普通同步。它是一个中等速度的检测器。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUncalledPrivateMethods">
    <Details>
<![CDATA[
<p> 此检测器查找从未调用的私有方法
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StringConcatenation">
    <Details>
<![CDATA[
<p> 此检测器使用+查找循环中的字符串连接。 +.
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientInitializationInsideLoop">
    <Details>
<![CDATA[
<p>此检测器查找在循环内初始化的对象，这些对象可以移到外部以获得更好的性能。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientIndexOf">
    <Details>
<![CDATA[
<p> 此检测器查找使用String.indexOf(String)或String.lastIndexOf(String)的代码，传递长度为1的常量字符串。
建议使用效率更高的整数实现。是一个快速探测器。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientToArray">
    <Details>
<![CDATA[
<p> 此检测器使用toArray()方法查找将集合转换为数组的代码，
该方法采用原型数组，传递长度为零的数组参数。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InvalidJUnitTest">
    <Details>
<![CDATA[
<p> 此检测器查找格式错误的JUnit测试。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadlyOverriddenAdapter">
    <Details>
<![CDATA[
<p> 此检测器查找扩展Adapter类并覆盖具有错误签名的侦听器方法的代码。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadResultSetAccess">
    <Details>
<![CDATA[
<p> 此检测器查找对字段索引为0的结果集的getXXX或setXXX方法的调用。
    由于ResultSet字段从索引1开始，这总是一个错误。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuperfluousInstanceOf">
    <Details>
<![CDATA[
<p> 此检测器使用instanceof运算符查找类型检查，其中可以静态地进行确定。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.BadAppletConstructor">
    <Details>
<![CDATA[
<p>
此检测器查找调用父applet中依赖于applet存根的方法的applet构造函数。
因为这个存根直到init()方法之前才被初始化，所以这些方法在构造函数中会失败。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.SuspiciousThreadInterrupted">
    <Details>
<![CDATA[
<p>
此检测器查找从非静态上下文对Thread.interrupted()的调用。
如果它是从Thread.currentThread().interrupted()中调用的，那么它只是一个无用的练习，只需使用Thread.interrupted()。
但是，如果在任意线程对象上调用它，则很可能会报错，因为interrupt()总是在当前线程上调用。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSqlInjection">
    <Details>
<![CDATA[
<p>
此检测器使用数据流分析来查找对switch中SQL语句的execute方法的调用，将常量字符串以外的其他内容作为参数传递。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindDeadLocalStores">
    <Details>
<![CDATA[
<p>
此检测器查找从未随后读取的局部变量的赋值。它是一个中等速度的检测器。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindMaskedFields">
    <Details>
<![CDATA[
<p> 此检测器查找由方法中定义的本地字段屏蔽的类级字段。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.WrongMapIterator">
    <Details>
<![CDATA[
<p>此检测器使用从键集迭代器检索的键来查找访问Map条目的值。</p>
]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InstantiateStaticClass">
    <Details>
<![CDATA[
<p> 此检测器查找基于仅定义静态方法的类创建对象的代码。
</p>
]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RuntimeExceptionCapture">
    <Details>
<![CDATA[
<p> 当块中没有代码引发异常时，此检测器查找捕获异常的catch子句 </p>
]]>
     </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindFloatEquality">
    <Details>
<![CDATA[
<p> 查找浮点相等表达式。快速探测器。 </p>
]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnsatisfiedObligation">
    <Details>
<![CDATA[
<p>此检测器查找方法的所有路径上未清理的IO流和数据库资源。这是一个慢速检测器。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UnnecessaryMath">
    <Details>
<![CDATA[
<p>此检测器查找对常量值调用java.lang.Math静态方法的代码，其中结果值是静态已知的常量。
其中结果值是静态已知的常量。改为使用常量更快，有时更准确。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindCircularDependencies">
    <Details>
<![CDATA[
<p>此检测器查看类之间的循环依赖关系。</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.RedundantInterfaces">
    <Details>
<![CDATA[
<p>此检测器查找声明它们实现与超类相同的接口的类。
这是多余的，如果一个超类实现了一个接口，那么这个子类也是。.</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MultithreadedInstanceAccess">
    <Details>
<![CDATA[
<p>此检测器查找实现Struts框架时的潜在问题。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.PublicSemaphores">
    <Details>
<![CDATA[
<p>此检测器查找同步并在此上使用wait()、Notify()或NotifyAll()的公共类。
这将同步实现公开为类的公共构件。
类的客户端可能会使用类的实例作为其自己的同步对象，并对基础实现造成严重破坏。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.MethodReturnCheck">
    <Details>
<![CDATA[
<p> 此检测器查找对返回值被可疑忽略的方法的调用。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.IDivResultCastToDouble">
    <Details>
<![CDATA[
<p>
此检测器查找整数除法结果被强制转换为Double的位置。
通常，这意味着将整数操作数强制转换为double，然后执行除法。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBadCast2">
    <Details>
<![CDATA[
<p>
此检测器使用数据流分析查找对象引用的错误强制转换。
</p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableStoreIntoSession">
    <Details>
<![CDATA[
<p>
此检测器查找将不可序列化对象存储到HTTP会话中。
</p>
]]>
    </Details>
  </Detector>

  <Detector class="edu.umd.cs.findbugs.detect.FindUseOfNonSerializableValue">
    <Details>
<![CDATA[
<p>
此检测器在需要可序列化的上下文中查找不可序列化对象的用法。
</p>
]]>
    </Details>
  </Detector>


  <Detector class="edu.umd.cs.findbugs.detect.FindNonSerializableValuePassedToWriteObject">
    <Details>
<![CDATA[
<p>
此检测器查找传递给ObjectOutput的writeObject方法的不可序列化对象。
</p>
]]>
    </Details>
  </Detector>



  <Detector class="edu.umd.cs.findbugs.detect.BadSyntaxForRegularExpression">
    <Details>
<![CDATA[
<p> This detector looks for regular expressions that have invalid syntax.  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindPuzzlers">
    <Details>
<![CDATA[
<p>此检测器问题查找Joshua Bloch和Neal Gafter在编程Puzzler的工作中提到的杂项小错误。
  </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindSleepWithLockHeld">
    <Details>
      <![CDATA[
      <p>
         此检测器查找在持有锁的情况下对Thread.sleep()的调用。这是一个缓慢的探测器。
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DuplicateBranches">
    <Details>
<![CDATA[
<p> 此检测器查找对于两个分支具有相同代码的ifelse或switch语句，从而使测试无用。
这通常是由于复制和粘贴两个分支造成的，导致一个分支的逻辑不正确</p><p></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.InefficientMemberAccess">
    <Details>
<![CDATA[
<p> 当成员变量为私有时，此检测器查找写入所属类的成员变量的内部类。
在这种情况下，需要使用一个特殊的编译器生成的存取器方法来写入这个变量。
将可见性放宽为受保护将允许直接写入字段。</p>
<p></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.XMLFactoryBypass">
    <Details>
<![CDATA[
<p> 此检测器查找XML接口实现的直接分配。
这将代码绑定到特定的实现，而不是使用提供的工厂模式来创建这些对象。</p>
<p></p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.UselessSubclassMethod">
    <Details>
      <![CDATA[
      <p>
此检测器查找实现超类中定义的方法的子类，
这些子类只将未触及的参数传递给父类方法。
这些方法可以直接删除。
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.ConfusedInheritance">
    <Details>
      <![CDATA[
      <p>
      此检测器用于声明受保护成员的最终类。
      由于无法从此类派生，因此对成员使用受保护的访问是不正确的。访问权限应更改为public或private，以表示字段的正确意图。
      这可能是由于这个类的使用发生了变化，而没有将所有的类完全改变为新的范例。
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.QuestionableBooleanAssignment">
    <Details>
      <![CDATA[
      <p>
      此检测器查找条件表达式中变量的文字布尔值的简单赋值。
      </p>
      <p></p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNullReturnValues">
    <Details>
      <![CDATA[
      <p>
      TrainNullReturnValues确定哪些方法可能返回NULL并将其保存到文件中。所得到的文件可以在随后的传递中使用，以提高空解引用检测器的精度。
      由于这只是一次培训通行证，因此不会报告任何警告。
      </p>
      <p>
      这是慢速检测器。
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainUnconditionalDerefParams">
    <Details>
      <![CDATA[
      <p>
      TrainUncondition alParamDerefs确定哪些方法可以无条件地取消对参数的引用，并将它们保存到文件中。
      所得到的文件可以在随后的传递中使用，以提高空解引用检测器的精度。
      由于这只是一次培训通行证，因此不会报告任何警告。
      </p>
      <p>
    这是慢速检测器。
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainFieldStoreTypes">
    <Details>
      <![CDATA[
      <p>
      TrainFieldStoreTypes分析存储在字段中的类型并将其存储到数据库中。
      数据库可以在以后的传递中使用，以使类型分析更精确。
      </p>
      <p>
      这是慢速检测器。
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TrainNonNullAnnotations">
    <Details>
      <![CDATA[
      <p>
    TrainNonNullAnnotations收集@Nonnull和@PossiblyNull注释，并将它们存储到数据库文件中。
    这是一个快速探测器。
      </p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckCalls">
    <Details>
      <![CDATA[
      <p>此检测器仅用于调试FindBugs中的方法调用解析。不要启用它</p>
      ]]>
   </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindBugsSummaryStats">
    <Details>
<![CDATA[
<p>此检测器仅收集有关分析过程的摘要统计信息。 </p>
]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestASM">
    <Details>
    <![CDATA[
    <p>
    此检测器是一个代码示例，展示了如何使用ASM字节码分析框架编写FindBugs检测器。
    </p>
    ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.FindUnrelatedTypesInGenericContainer">
    <Details>
    <![CDATA[
    <p> 此检测器查看对接收<code>java.lang.Object<code>的泛型集合方法的调用的参数，以查看参数的类型是否与集合的参数相关。
    具有不相关类型的参数永远不会出现在集合中。
    例如，如果<code>foo<code>是<code>list&lt；string&gt；<code>而<code>bar<code>是<code>StringBuffer<code>，
    则调用<code>foo.containers(Bar)<code>将始终返回false。
    这是一个快速探测器。
    </p>
    ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.StaticCalendarDetector">
    <Details>
<![CDATA[
<p>此检测器对java.util.Calendar或java.text.DateFormat(以及子类)类型的静态字段发出警告，因为日历对于多线程使用本质上是不安全的
</p>
]]>
</Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.TestDataflowAnalysis">
    <Details>
      <![CDATA[
          <p>这是仅用于测试数据流分析的内部检测器。默认情况下不启用。</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckTypeQualifiers">
    <Details>
      <![CDATA[
        <p>检查JSR-305类型限定符批注指定的属性是否存在冲突。
        </p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.AppendingToAnObjectOutputStream">
    <Details>
      <![CDATA[
        <p>查找追加到对象输出流的尝试</p>
      ]]>
    </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckExpectedWarnings">
    <Details>
          <![CDATA[
          <p>检查@ExpectedWarning和@NoWarning批注。此检测器仅用于测试FindBugs。</p>
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DontIgnoreResultOfPutIfAbsent">
    <Details>
          <![CDATA[
          <p>检查如果忽略putIfAbsend的结果，则不重用作为第二个参数传递的值</p>
          ]]>
      </Details>
  </Detector>
  <Detector
    class="edu.umd.cs.findbugs.detect.ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass">
    <Details>
          <![CDATA[
          <p>检查从超类的构造函数调用的方法。  </p>
          ]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.DefaultEncodingDetector">
    <Details>
<![CDATA[
<p> 检查对使用用户默认平台编码执行字节到字符串(或字符串到字节)转换的方法的调用。
这可能会导致应用程序行为在不同平台之间发生变化。  </p>
]]>
      </Details>
  </Detector>
  <Detector class="edu.umd.cs.findbugs.detect.CheckRelaxingNullnessAnnotation">
    <Details>
      <![CDATA[
        <p>检查重写方法不会放松返回值的@Nonnull(make@CheckForNull)或参数的@CheckForNull(make@Nonnull)。</p>
      ]]>
      </Details>
  </Detector>
  <!--
  **********************************************************************
  BugPatterns错误模式
  **********************************************************************
   -->
  <BugPattern type="CNT_ROUGH_CONSTANT_VALUE">
    <ShortDescription>找到已知常量的粗糙值</ShortDescription>
    <LongDescription>找到{3}的粗糙值：{2}</LongDescription>
    <Details>
      <![CDATA[
    <p>为了代码清晰和更好的精度，建议使用预定义的库常量。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SKIPPED_CLASS_TOO_BIG">
  <ShortDescription>类太大，无法分析</ShortDescription>
  <LongDescription>{0}太大，无法分析</LongDescription>
    <Details>
      <![CDATA[
    <p>此类的大小超出了可以有效处理的范围，并且没有完全分析错误。
</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_NULL_DEREFERENCE">
   <ShortDescription>关于空指针取消引用的虚假警告</ShortDescription>
<LongDescription>关于{1}中的空指针取消引用的虚假警告</LongDescription>
    <Details>
      <![CDATA[
    <p>虚假警告.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_METHOD_CALL">
    <ShortDescription>关于字段引用的虚假警告</ShortDescription>
<LongDescription>关于{1}中对{2}的引用的虚假警告</LongDescription>
    <Details>
      <![CDATA[
    <p>虚假警告.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_FIELD_REFERENCE">
    <ShortDescription>关于字段引用的虚假警告</ShortDescription>
<LongDescription>关于{1}中对{2}的引用的虚假警告</LongDescription>
    <Details>
      <![CDATA[
    <p>虚假警告</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NOISE_OPERATION">
    <ShortDescription>关于操作的虚假警告</ShortDescription>
<LongDescription>关于操作的虚假警告{1}</LongDescription>
    <Details>
      <![CDATA[
    <p>虚假警告</p>
]]>
    </Details>
  </BugPattern>
    <BugPattern type="DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE">
        <ShortDescription>关于操作的虚假警告</ShortDescription>
<LongDescription>关于操作的虚假警告{1}</LongDescription>
        <Details>
      <![CDATA[
    <p>
此代码从不能很好地转换为十进制数的双精度值创建BigDecimal。
例如，可以假设用Java语言编写新的BigDecimal(0.1BigDecimal)创建的BigDecimal正好等于0.1BigDecimal(未缩放的值为1，小数位数为1)，但它实际上等于0.1000000000000000055511151231257827021181583404541015625.
您可能希望使用BigDecimal.valueOf(Double D)方法，该方法使用double的字符串表示来创建BigDecimal(例如，BigDecimal.valueOf(0.1)给出0.1)。
</p>

]]>
    </Details>
    </BugPattern>

    <BugPattern type="DMI_DOH">
       <ShortDescription>哦！无意义的方法调用</ShortDescription>
<LongDescription>哦！{1}中{2.nameAndSignature}的无意义调用</LongDescription>
        <Details>
      <![CDATA[
    <p>
此部分方法调用没有意义，原因从检查中应该是显而易见的。
</p>

]]>
    </Details>
    </BugPattern>

  <BugPattern type="DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD">
    <ShortDescription>对EasyMock方法的Uselessvacous调用</ShortDescription>
<LongDescription>对{1}中的{2}的Uselessvacous调用</LongDescription>
<Details>
      <![CDATA[
    <p>此调用不会将任何对象传递给EasyMock方法，因此该调用不会执行任何操作。
</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS">
    <ShortDescription>创建具有零核线程的ScheduledThreadPoolExecutor</ShortDescription>
    <LongDescription>在{1}中创建具有零核心线程的ScheduledThreadPoolExecutor</LongDescription>
     <Details>
      <![CDATA[
    <p>(<a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#ScheduledThreadPoolExecutor(int)">Javadoc</a>)
具有零核心线程的ScheduledThreadPoolExecutor永远不会执行任何操作; 最大池大小的更改将被忽略。
</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR">
    <ShortDescription>尝试更改ScheduledThreadPoolExecutor的最大池大小无效</ShortDescription>
<LongDescription>尝试更改{1}中ScheduledThreadPoolExecutor的最大池大小无效</LongDescription>
    <Details>
      <![CDATA[
    <p>(<a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">Javadoc</a>)
虽然ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，但一些继承的调优方法对它没用。
特别是，因为它使用corePoolSize线程和无界队列充当固定大小的池，
所以对maximumPoolSize的调整没有任何有用的效果。
    </p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_UNSUPPORTED_METHOD">
    <ShortDescription>调用不支持的方法</ShortDescription>
<LongDescription>调用{1}中不支持的方法{2}</LongDescription>
    <Details>
      <![CDATA[
    <p>此方法调用的所有目标都引发 Unsupported Operation Exception。
</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_EMPTY_DB_PASSWORD">
    <ShortDescription>空数据库密码</ShortDescription>
<LongDescription>{1}中的数据库密码为空</LongDescription>
    <Details>
      <![CDATA[
    <p>此代码使用空白或空密码创建数据库连接。这表示数据库不受密码保护。
</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CONSTANT_DB_PASSWORD">
    <ShortDescription>硬编码常量数据库密码</ShortDescription>
<LongDescription>{1}中的硬编码常量数据库密码</LongDescription>
    <Details>
      <![CDATA[
    <p>此代码使用硬编码的常量密码创建数据库连接。任何有权访问源代码或编译代码的人都可以轻松地学习密码
</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_COOKIE">
    <ShortDescription>HTTP cookie由不受信任的输入形成</ShortDescription>
<LongDescription>HTTP Cookie由{1}中的不受信任的输入形成</LongDescription>
    <Details>
      <![CDATA[
    <p>此代码使用不受信任的HTTP参数构造HTTP Cookie。 如果将此cookie添加到HTTP响应中，则会允许HTTP响应拆分漏洞。
     See <a href="http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>
for more information.</p>
<p>FindBugs只查找最明显，最明显的HTTP响应拆分案例。
如果FindBugs找到<em>任何</ em>，那么<em>几乎肯定</ em>有更多的漏洞，FindBugs不会报告。 
如果您担心HTTP响应拆分，您应该认真考虑使用商业静态分析或笔测试工具。
</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="HRS_REQUEST_PARAMETER_TO_HTTP_HEADER">
    <ShortDescription>HTTP响应拆分漏洞</ShortDescription>
<LongDescription>HTTP参数直接写入{1}中的HTTP标头输出</LongDescription>
    <Details>
            <![CDATA[
    <p>This code directly writes an HTTP parameter to an HTTP header, which allows for a HTTP response splitting
vulnerability. See <a href="http://en.wikipedia.org/wiki/HTTP_response_splitting">http://en.wikipedia.org/wiki/HTTP_response_splitting</a>
for more information.</p>
<p>FindBugs looks only for the most blatant, obvious cases of HTTP response splitting.
If FindBugs found <em>any</em>, you <em>almost certainly</em> have more
vulnerabilities that FindBugs doesn't report. If you are concerned about HTTP response splitting, you should seriously
consider using a commercial static analysis or pen-testing tool.
</p>

]]>
        </Details>
  </BugPattern>



  <BugPattern type="PT_RELATIVE_PATH_TRAVERSAL">
    <ShortDescription>Servlet中的相对路径遍历</ShortDescription>
<LongDescription>{1}中的相对路径遍历</LongDescription>
    <Details>
<![CDATA[
    <p>The software uses an HTTP request parameter to construct a pathname that should be within a restricted directory, but it does not properly neutralize sequences such as ".." that can resolve to a location that is outside of that directory.

See <a href="http://cwe.mitre.org/data/definitions/23.html">http://cwe.mitre.org/data/definitions/23.html</a>
for more information.</p>
<p>FindBugs looks only for the most blatant, obvious cases of relative path traversal.
If FindBugs found <em>any</em>, you <em>almost certainly</em> have more
vulnerabilities that FindBugs doesn't report. If you are concerned about relative path traversal, you should seriously
consider using a commercial static analysis or pen-testing tool.
</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="PT_ABSOLUTE_PATH_TRAVERSAL">
    <ShortDescription>Servlet中的绝对路径遍历</ShortDescription>
<LongDescription>{1}中的绝对路径遍历</LongDescription>
    <Details>
<![CDATA[
    <p>The software uses an HTTP request parameter to construct a pathname that should be within a restricted directory,
but it does not properly neutralize absolute path sequences such as "/abs/path" that can resolve to a location that is outside of that directory.

See <a href="http://cwe.mitre.org/data/definitions/36.html">http://cwe.mitre.org/data/definitions/36.html</a>
for more information.</p>
<p>FindBugs looks only for the most blatant, obvious cases of absolute path traversal.
If FindBugs found <em>any</em>, you <em>almost certainly</em> have more
vulnerabilities that FindBugs doesn't report. If you are concerned about absolute path traversal, you should seriously
consider using a commercial static analysis or pen-testing tool.
</p>

]]>
    </Details>
  </BugPattern>

  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER">
    <ShortDescription>Servlet反映的跨站点脚本漏洞</ShortDescription>
<LongDescription>HTTP参数写入{1}中的Servlet输出</LongDescription>
    <Details>
<![CDATA[
    <p>This code directly writes an HTTP parameter to Servlet output, which allows for a reflected cross site scripting
vulnerability. See <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>
for more information.</p>
<p>FindBugs looks only for the most blatant, obvious cases of cross site scripting.
If FindBugs found <em>any</em>, you <em>almost certainly</em> have more cross site scripting
vulnerabilities that FindBugs doesn't report. If you are concerned about cross site scripting, you should seriously
consider using a commercial static analysis or pen-testing tool.
</p>

]]>
    </Details>
  </BugPattern>


  <BugPattern type="XSS_REQUEST_PARAMETER_TO_SEND_ERROR">
    <ShortDescription>Servlet反映了错误页面中的跨站点脚本漏洞</ShortDescription>
<LongDescription>HTTP参数已写入{1}中的Servlet错误页</LongDescription>
    <Details>
<![CDATA[
    <p>This code directly writes an HTTP parameter to a Server error page (using HttpServletResponse.sendError). Echoing this untrusted input allows
for a reflected cross site scripting
vulnerability. See <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>
for more information.</p>
<p>FindBugs looks only for the most blatant, obvious cases of cross site scripting.
If FindBugs found <em>any</em>, you <em>almost certainly</em> have more cross site scripting
vulnerabilities that FindBugs doesn't report. If you are concerned about cross site scripting, you should seriously
consider using a commercial static analysis or pen-testing tool.
</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="XSS_REQUEST_PARAMETER_TO_JSP_WRITER">
    <ShortDescription>JSP反映了跨站点脚本漏洞</ShortDescription>
<LongDescription>HTTP参数直接写入JSP输出，给出了{1.class}中反映的XSS漏洞</LongDescription>
    <Details>
<![CDATA[
    <p>This code directly writes an HTTP parameter to JSP output, which allows for a cross site scripting
vulnerability. See <a href="http://en.wikipedia.org/wiki/Cross-site_scripting">http://en.wikipedia.org/wiki/Cross-site_scripting</a>
for more information.</p>
<p>FindBugs looks only for the most blatant, obvious cases of cross site scripting.
If FindBugs found <em>any</em>, you <em>almost certainly</em> have more cross site scripting
vulnerabilities that FindBugs doesn't report. If you are concerned about cross site scripting, you should seriously
consider using a commercial static analysis or pen-testing tool.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SW_SWING_METHODS_INVOKED_IN_SWING_THREAD">
    <ShortDescription>某些Swing方法需要在Swing线程中调用</ShortDescription>
<LongDescription>需要在Swing事件线程中执行{1}中对Swing方法的调用</LongDescription>
    <Details>
<![CDATA[
<p>(<a href="http://web.archive.org/web/20090526170426/http://java.sun.com/developer/JDCTechTips/2003/tt1208.html">From JDC Tech Tip</a>): The Swing methods
show(), setVisible(), and pack() will create the associated peer for the frame.
With the creation of the peer, the system creates the event dispatch thread.
This makes things problematic because the event dispatch thread could be notifying
listeners while pack and validate are still processing. This situation could result in
two threads going through the Swing component-based GUI -- it's a serious flaw that
could result in deadlocks or other related threading issues. A pack call causes
components to be realized. As they are being realized (that is, not necessarily
visible), they could trigger listener notification on the event dispatch thread.</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_LOOP">
    <ShortDescription>明显的无限循环</ShortDescription>
<LongDescription>{1}中存在明显的无限循环</LongDescription>
    <Details>
<![CDATA[
<p>此循环似乎没有终止方法(除了可能引发异常).</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_INFINITE_RECURSIVE_LOOP">
    <ShortDescription>显式无限递归循环</ShortDescription>
<LongDescription>{1}中存在明显的无限递归循环</LongDescription>
    <Details>
<![CDATA[
<p>此方法无条件调用自身。这似乎表示将导致堆栈溢出的无限递归循环。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IL_CONTAINER_ADDED_TO_ITSELF">
    <ShortDescription>集合被添加到自身</ShortDescription>
<LongDescription>集合已添加到{1}中的自身</LongDescription>
    <Details>
<![CDATA[
<p>集合已添加到自身。因此，计算此集合的hashCode将抛出StackOverflowException。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_REFERENCE_TO_ARRAY">
    <ShortDescription>对数组的volatile引用不会将数组元素视为volatile</ShortDescription>
<LongDescription>{1}是对数组的易失性引用；数组元素是非易失性的</LongDescription>
    <Details>
<![CDATA[
<p>这声明了对数组的volatile引用，这可能不是您想要的。
对于对数组的易失性引用，对数组的引用的读取和写入被视为易失性，但数组元素是非易失性的。
要获取易失性数组元素，您将需要使用java.util.current(在Java 5.0中提供)中的一个原子数组类。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="VO_VOLATILE_INCREMENT">
    <ShortDescription>易失性字段的增量不是原子的</ShortDescription>
<LongDescription>{1}中易失性字段{2}的增量</LongDescription>
    <Details>
<![CDATA[
<p>此代码递增易失性字段。易失性字段的增量不是原子的。如果多个线程同时递增字段，增量可能会丢失。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UI_INHERITANCE_UNSAFE_GETRESOURCE">
    <ShortDescription>如果类被扩展，GetResource的使用可能是不安全的</ShortDescription>
<LongDescription>如果扩展类，则{1}中GetResource的使用可能不安全</LongDescription>
    <Details>
<![CDATA[
<p>调用<code>this.getClass().getResource(.)<code>如果此类由另一个包中的类扩展，则可能会产生与预期不同的结果。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_BOOLEAN_RETURN_NULL">
   <ShortDescription>具有Boolean返回类型的方法返回显式NULL</ShortDescription>
<LongDescription>{1}具有Boolean返回类型并返回显式NULL</LongDescription>
    <Details>
       <![CDATA[
       <p>
    返回Boolean.TRUE、Boolean.FALSE或NULL的方法是等待发生的意外。
    可以调用此方法，就好像它返回了Boolean类型的值一样，并且编译器将插入布尔值的自动拆箱。
    如果返回NULL值，这将导致NullPointerException。
       </p>
       ]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_OPTIONAL_RETURN_NULL">
    <ShortDescription>具有可选返回类型的方法返回显式NULL</ShortDescription>
<LongDescription>{1}具有可选的返回类型并返回显式NULL</LongDescription>
    <Details>
       <![CDATA[
       <p>
    可选返回类型(java.util.Optional或com.google.common.base.Optiona)的使用始终意味着显式NULL返回不是设计所需的。
    在这种情况下返回NULL值是违反合同的，并且极有可能破坏客户代码
       </p>
       ]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>非空字段未初始化</ShortDescription>
<LongDescription>非空字段{2.name}未由{1}初始化</LongDescription>
    <Details>
       <![CDATA[
       <p> <p>该字段被标记为非NULL，但构造函数未写入该字段。
       该字段可能在构造函数期间在其他地方初始化，或者可能总是在使用之前初始化
       </p>
       ]]>
       </Details>
  </BugPattern>
  <BugPattern type="NP_SYNC_AND_NULL_CHECK_FIELD">
    <ShortDescription>对同一字段进行同步和NULL检查。</ShortDescription>
<LongDescription>在{1}中，对字段{2.givenClass}进行同步，然后检查是否为NULL。</LongDescription>
    <Details>
<![CDATA[
<p>因为该字段是同步的，所以它似乎不太可能为null。如果它是NULL，然后在NullPointerException上进行同步，将引发异常，并且检查将是没有意义的。
   最好在另一个字段上同步。</p>

]]>
     </Details>
  </BugPattern>
  <BugPattern type="RpC_REPEATED_CONDITIONAL_TEST">
    <ShortDescription>重复条件检验</ShortDescription>
    <LongDescription>{1}中重复的条件测试</LongDescription>
    <Details>
<![CDATA[
<p>包含条件测试的代码执行两次，一个接一个(例如，<code>x=0|x=0)。也许第二次出现的目的是其他的(例如，<code>x=0|y=0<code>)。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING">
    <ShortDescription>测试</ShortDescription>
<LongDescription>{1}中生成的测试警告</LongDescription>
    <Details>
<![CDATA[
<p>此错误模式仅由新的、未完全实现的错误检测器生成。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING1">
    <ShortDescription>测试1</ShortDescription>
<LongDescription>{1}中生成的测试警告1</LongDescription>
    <Details>
<![CDATA[
<p>此错误模式仅由新的、未完全实现的错误检测器生成</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING2">
    <ShortDescription>测试2</ShortDescription>
<LongDescription>{1}中生成的测试警告2</LongDescription>
    <Details>
<![CDATA[
<p>此错误模式仅由新的、未完全实现的错误检测器生成。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="TESTING3">
    <ShortDescription>测试3</ShortDescription>
<LongDescription>{1}中生成的测试警告3</LongDescription>
<Details>
<![CDATA[
<p>此错误模式仅由新的、未完全实现的错误检测器生成。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UNKNOWN">
    <ShortDescription>未知错误模式</ShortDescription>
<LongDescription>{1}中的未知bug模式bug_pattern</LongDescription>
    <Details>
<![CDATA[
<p>记录了警告，但findbugs找不到对此错误模式的描述，因此无法对其进行描述。这应该仅在FindBugs或其配置中出现错误的情况下发生，或者如果分析是使用插件生成的，但该插件当前未加载。
.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_ZIP_FILE_ENTRY">
    <ShortDescription>创建空的zip文件条目</ShortDescription>
<LongDescription>在{1}中创建的空zip文件条目</LongDescription>
    <Details>
<![CDATA[
<p>代码调用<code>putNextEntry()<code>，然后立即调用<code>closeEntry()<code>。
这将导致一个空的zipfile条目。条目的内容应该在调用<code>putNextEntry()<code>和<code>closeEntry()<code>之间写入zipfile。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="AM_CREATES_EMPTY_JAR_FILE_ENTRY">
    <ShortDescription>创建空的JAR文件条目</ShortDescription>
    <LongDescription>在{1}中创建的空JAR文件条目</LongDescription>
    <Details>
<![CDATA[
<p>代码调用<code>putNextEntry()<code>，然后立即调用<code>closeEntry()<code>。这将导致一个空的JarFile条目。条目的内容应该在调用<code>putNextEntry()<code>和<code>closeEntry()<code>之间写入JarFile。.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IMSE_DONT_CATCH_IMSE">
    <ShortDescription>IllegalMonitorStateException的可疑捕获</ShortDescription>
<LongDescription>{1}中IllegalMonitorStateException的捕获可疑</LongDescription>
    <Details>
<![CDATA[
<p>IllegalMonitorStateException通常仅在代码中存在设计缺陷(在未锁定的对象上调用Wait或Notify)时引发.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FL_MATH_USING_FLOAT_PRECISION">
    <ShortDescription>方法使用浮点精度执行数学运算</ShortDescription>
<LongDescription>{1}使用浮点精度执行数学运算</LongDescription>
    <Details>
<![CDATA[
<p>
   该方法使用浮点精度执行数学运算。浮点精度非常不精确。例如，16777216.0f+1.0f=16777216.0f。请考虑改用双重数学.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_FIELD">
    <ShortDescription>对字段的协变数组赋值</ShortDescription>
<LongDescription>类型为{2}的数组分配给类型为{3}的字段</LongDescription>
    <Details>
<![CDATA[
<p>协变类型数组被分配给局部变量。这很容易混淆，并且可能会在运行时导致ArrayStoreException，如果其他类型的引用稍后将像下面的代码一样存储在此数组中：
</p>
<p><code>Number[] arr = new Integer[10];
arr[0] = 1.0;
</code></p>
<p>考虑更改创建的数组的类型或局部变量类型</p>   	
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_LOCAL">
    <ShortDescription>方法返回协变数组</ShortDescription>
<LongDescription>从返回类型为{3}的方法返回类型为{2}的数组</LongDescription>
    <Details>
<![CDATA[
<p>方法返回协变类型数组。这是令人困惑的，并且如果调用代码将尝试在返回的数组中存储其他类型的引用，则可能会在运行时导致ArrayStoreException。
</p>
<p><code>Number[] arr = new Integer[10];
arr[0] = 1.0;
</code></p>
<p>考虑更改已创建数组的类型或方法返回类型。</p>   	
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_RETURN">
    <ShortDescription>可能不兼容的元素存储在协变数组中</ShortDescription>
<LongDescription>类型为{2}的值存储在元素类型为{3}的数组中</LongDescription>
    <Details>
<![CDATA[
<p>方法返回协变类型数组。这是令人困惑的，并且如果调用代码将尝试在返回的数组中存储其他类型的引用，则可能会在运行时导致ArrayStoreException。
</p>
<p>考虑更改已创建数组的类型或方法返回类型。</p>   	
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CAA_COVARIANT_ARRAY_ELEMENT_STORE">
    <ShortDescription>可能不兼容的元素存储在协变数组中</ShortDescription>
<LongDescription>类型为{2}的值存储在元素类型为{3}的数组中</LongDescription>
    <Details>
<![CDATA[
<p>值存储在数组中，值类型与数组类型不匹配。从分析中可以知道，实际的数组类型比其变量或字段的声明类型窄，并且这个赋值不满足原始的数组类型。
此赋值可能会导致运行时出现ArrayStoreException。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM">
    <ShortDescription>类实现cloneable，但没有定义或使用clone方法</ShortDescription>
<LongDescription>类{0}实现了cloneable，但没有定义或使用clone方法</LongDescription>
    <Details>
<![CDATA[
<p>
   类实现了cloneable，但没有定义或使用clone方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE">
    <ShortDescription>类定义clone()，但不实现cloneable</ShortDescription>
<LongDescription>{0}定义clone()但未实现cloneable</LongDescription>
    <Details>
<![CDATA[
<p> 此类定义了clone()方法，但该类没有实现cloneable。在某些情况下，这是可以的(例如，您想控制子类如何克隆自己)，但只需确保这就是您想要的
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CN_IDIOM_NO_SUPER_CALL">
    <ShortDescription>clone方法未调用super.clone()</ShortDescription>
<LongDescription>{1}未调用super.clone()</LongDescription>
    <Details>
<![CDATA[
<p> This non-final class defines a clone() method that does not call super.clone().
If this class ("<i>A</i>") is extended by a subclass ("<i>B</i>"),
and the subclass <i>B</i> calls super.clone(), then it is likely that
<i>B</i>'s clone() method will return an object of type <i>A</i>,
which violates the standard contract for clone().</p>

<p> If all clone() methods call super.clone(), then they are guaranteed
to use Object.clone(), which always returns an object of the correct type.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER">
    <ShortDescription>在较高版本的Java中使用作为关键字的标识符</ShortDescription>
<LongDescription>{1}使用{2}作为变量名，这是Java更高版本中的关键字</LongDescription>
    <Details>
<![CDATA[
<p>标识符是一个字，在以后的Java版本中保留为关键字，为了在以后的Java版本中编译它，需要更改您的代码.</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER">
    <ShortDescription>在较高版本的Java中使用作为关键字的标识符</ShortDescription>
<LongDescription>{1}与较新版本的Java中的关键字冲突</LongDescription>
    <Details>
<![CDATA[
<p>此标识符在以后的Java版本中用作关键字。
需要更改此代码以及引用此API的任何代码，以便在更高版本的Java中编译它。.</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_DROP">
    <ShortDescription>方法可能会丢弃异常</ShortDescription>
<LongDescription>{1}可能会丢弃{2}</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法可能会丢弃异常。
  通常，应该以某种方式处理或报告异常，或者应该将它们抛出方法.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DE_MIGHT_IGNORE">
    <ShortDescription>方法可能会忽略异常</ShortDescription>
<LongDescription>{1}可能忽略{2}</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法可能会忽略异常。&nbsp；通常，应该以某种方式处理或报告异常，或者应该将它们抛出方.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEGED">
    <ShortDescription>应仅在doPrivileged块内调用的已调用方法</ShortDescription>
<LongDescription>在{1}中调用{2}，应从doPrivileged块内调用</LongDescription>
    <Details>
<![CDATA[
  <p> 此代码调用需要安全权限检查的方法。如果此代码将被授予安全权限，
  但可能被不具有安全权限的代码调用，则调用需要在doPrivileged块内进行.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_DO_INSIDE_DO_PRIVILEDGED">
    <!-- misspelled for backward compatibility -->
    <ShortDescription>应仅在doPrivileged块内调用的已调用方法</ShortDescription>
<LongDescription>在{1}中调用{2}，应从doPrivileged块内调用</LongDescription>
    <Details>
<![CDATA[
  <p>此代码调用需要安全权限检查的方法。如果此代码将被授予安全权限，但可能被不具有安全权限的代码调用，则调用需要在doPrivileged块内进行。.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED">
    <ShortDescription>Classloader只能在doPrivileged块内创建</ShortDescription>
<LongDescription>{1}创建{2}类加载器，应在doPrivileged块内执行</LongDescription>

    <Details>
<![CDATA[
  <p> 此代码创建一个类加载器，如果安装了安全管理器，则需要权限。如果此代码可能由没有安全权限的代码调用，则需要在doPrivileged块内创建类加载器</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS">
   <ShortDescription>不变类的字段应该是final</ShortDescription>
<LongDescription>{1.givenClass}应为final，因为{0}标记为不可变。</LongDescription>
    <Details>
<![CDATA[
  <p> 该类使用net.jcip.annotations.Immutable或javax.annotation.concurrent.Immutable进行批注，并且这些批注的规则要求所有字段都是final
   .</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED">
  <ShortDescription>线程传递到预期Runnable的位置</ShortDescription>
<LongDescription>在{1}中预期Runnable的位置传递了线程</LongDescription>
    <Details>
<![CDATA[
  <p> 将Thread对象作为参数传递给需要Runnable的方法。这是相当不寻常的，可能表示逻辑错误或导致意外行为
   </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTION_OF_URLS">
    <ShortDescription>地图和URL集可以是性能消耗</ShortDescription>
<LongDescription>{1}是或使用映射或URL集，这可能是性能问题</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法或字段是或使用地图或网址集。 由于URL的equals和hashCode方法都执行域名解析，因此可能会导致性能大幅下降。
在 <a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a> 上查找更多资料.
可以考虑使用<code>java.net.URI</code> 来代替.
   </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BLOCKING_METHODS_ON_URL">
   <ShortDescription>URL的equals和hashCode方法被阻塞</ShortDescription>
<LongDescription>在{1}中调用{2}，阻止进行域名解析</LongDescription>
    <Details>
<![CDATA[
  <p> URL的equals和hashCode方法执行域名解析，这可能会导致性能大幅下降。
在 <a href="http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html">http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html</a> 上获取更多信息.
可用 <code>java.net.URI</code> 来替代.
   </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION">
    <ShortDescription>URL的equals和hashCode方法被阻塞</ShortDescription>
<LongDescription>在{1}中调用{2}，阻止进行域名解析</LongDescription>
    <Details>
<![CDATA[
  <p>除非注释本身已使用@Retention（RetentionPolicy.RUNTIME）注释，否则无法使用反射来观察注释（例如，通过使用isAnnotationPresent方法）。
   .</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_EXIT">
    <ShortDescription>方法调用System.exit(.)</ShortDescription>
<LongDescription>{1}调用System.exit(.)，关闭整个虚拟机</LongDescription>
    <Details>
<![CDATA[
  <p> 调用System.exit会关闭整个Java虚拟机。只有在适当的时候才应该这样做。这样的调用使得您的代码很难或不可能被其他代码调用。
  请考虑抛出RuntimeException.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_RUN_FINALIZERS_ON_EXIT">
    <ShortDescription>方法调用危险的方法runFinalizersOnExit</ShortDescription>
<LongDescription>{1}调用危险方法runFinalizersOnExit</LongDescription>
    <Details>
<![CDATA[
  <p> <em>任何原因都不要调用System.runFinalizersOnExit或Runtime.runFinalizersOnExit：它们是Java库中最危险的方法之一</em> -- Joshua Bloch</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_CTOR">
    <ShortDescription>方法调用效率低下的新字符串(字符串)构造函数</ShortDescription>
<LongDescription>{1}调用效率低下的新字符串(字符串)构造函数</LongDescription>
    <Details>
<![CDATA[
  <p> 使用<code>java.lang.String(String)<code>构造函数会浪费内存，因为这样构造的对象在功能上将无法与作为参数传递的<code>string<code>区分开来。
      只需直接使用参数<code>string<code></p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_VOID_CTOR">
    <ShortDescription>方法调用效率低下的new string()构造函数</ShortDescription>
<LongDescription>{1}调用效率低下的新String()构造函数</LongDescription>
    <Details>
<![CDATA[
  <p> 使用无参数构造函数创建新的<code> java.lang.String </ code>对象会浪费内存，
  因为这样创建的对象在功能上与空字符串常量无法区分 <code>""</code>.
  Java保证相同的字符串常量将由相同的<code> String </ code>对象表示
  因此，您应该直接使用空字符串常量。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_STRING_TOSTRING">
   <ShortDescription>方法对字符串调用toString()方法</ShortDescription>
<LongDescription>{1}对字符串调用toString()方法</LongDescription>
    <Details>
<![CDATA[
  <p> 调用<code>String.toString()<code>只是一个冗余操作。只需使用字符串</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_GC">
    <ShortDescription>显式垃圾收集；除非在基准测试代码中，否则非常可疑</ShortDescription>
<LongDescription>{1}强制垃圾收集；除了基准测试代码外，非常可疑</LongDescription>
    <Details>
<![CDATA[
  <p>代码显式调用垃圾回收。除了在基准测试中的具体使用，这是非常可疑的。</p>
  <p>过去，人们在Close或Finalize方法等例程中显式调用垃圾收集器的情况导致了巨大的性能黑洞。垃圾收集可能很昂贵。
  任何强制执行数百或数千次垃圾收集的情况都会使机器陷入困境</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOOLEAN_CTOR">
    <ShortDescription>方法调用效率低下的布尔构造函数；使用Boolean.valueOf(.)取而代之</ShortDescription>
<LongDescription>{1}调用效率低下的布尔构造函数；使用Boolean.valueOf(.)取而代之</LongDescription>
    <Details>
<![CDATA[
  <p> <code>创建<code>java.lang.Boolean<code>的新实例会浪费内存，因为<code>Boolean<code>对象是不可变的，并且只有两个此类型的有用值。&nbsp；使用<code>Boolean.valueOf()<code>方法(或Java 1.5自动装箱)来创建<code>Boolean<code>对象。
  使用<code>Boolean.valueOf()<code>方法(或Java 1.5 Autoboxing)来创建<code>Boolean<code>对象</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NUMBER_CTOR">
   <ShortDescription>方法调用效率低下的数字构造函数；改用静态值of</ShortDescription>
<LongDescription>{1}调用效率低下的{2}构造函数；请改用{3}</LongDescription>
    <Details>
      <![CDATA[
      <p>
      使用<code>new Integer(Int)<code>可以保证总是产生一个新对象，而<code>Integer.valueOf(Int)<code>允许由编译器、类库或JVM对值进行缓存。
      使用缓存值可以避免对象分配，并且代码会更快。
      </p>
      <p>
     -128到127之间的值保证具有相应的缓存实例，并且使用<code>value of<code>比使用构造函数快约3.5倍。对于常量范围之外的值，两种样式的性能是相同的。
      </p>
      <p>
      必须与Java 1.5之前的JVM兼容，否则在创建<code>long<code>、<code>Integer<code>、<code>short<code>、<code>character<code>和<code>Byte<code>的实例时，请使用自动装箱或<code>valueof()<code>方法
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_FP_NUMBER_CTOR">
   <ShortDescription>方法调用效率低下的浮点数构造函数；改用静态值of</ShortDescription>
<LongDescription>{1}调用效率低下的{2}构造函数；请改用{3}</LongDescription>
    <Details>
      <![CDATA[
      <p>
     使用<code>new double(Double)<code>可以保证总是产生一个新对象，而<code>Double.valueOf(Double)<code>允许由编译器、类库或JVM进行值的缓存。使用缓存值可以避免对象分配，并且代码会更快
      </p>
      <p>
     除非该类必须与Java 1.5之前的JVM兼容，否则在创建<code>double<code>和<code>float<code>的实例时，请使用自动装箱或<code>valueof()<code>方法.
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_CONVERT_CASE">
    <ShortDescription>考虑使用调用方法的区域设置参数化版本</ShortDescription>
<LongDescription>
在{1}中使用非本地化的String.toUpperCase()或String.toLowerCase()
</LongDescription>
    <Details>
<![CDATA[
  <p> 正在使用平台的默认编码将字符串转换为大写或小写。当与国际字符一起使用时，这可能会导致不正确的转换</p>
      <ul>
    <li>String.toUpperCase( Locale l )</li>
    <li>String.toLowerCase( Locale l )</li>
    </ul>
      <p>versions instead.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR">
    <ShortDescription>对三值运算符取消装箱和强制原始值</ShortDescription>
<LongDescription>对于{1}中的三值运算符，原始值已取消装箱和强制</LongDescription>
    <Details>
<![CDATA[
  <p>将包装的基元值取消装箱，并将其转换为另一个基元类型，作为条件三值运算符(<code>b？)求值的一部分。E1：E2<code>运算符)。
  Java的语义要求，如果<code>e1<code>和<code>e2<code>是包装的数值，则这些值被取消装箱并转换为它们的公共类型(例如，如果<code>e1<code>的类型是<code>Integer<code>并且<code>e2<code>的类型是<code>float<code>)，则<code>e1<code>被解箱，转换为浮点值，并装箱。
  参见JLS 15.25节
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED">
   <ShortDescription>对原始值进行装箱，然后立即取消装箱</ShortDescription>
<LongDescription>原始值在{1}中装箱，然后立即取消装箱</LongDescription>
    <Details>
<![CDATA[
  <p>对基本体进行装箱，然后立即取消装箱。这可能是由于在需要未装箱的值的地方进行手动装箱，从而迫使编译器立即撤消装箱的工作
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_UNBOXING_IMMEDIATELY_REBOXED">
   <ShortDescription>已装箱的值取消装箱，然后立即重新装箱</ShortDescription>
<LongDescription>已装箱的值已取消装箱，然后立即在{1}中重新装箱</LongDescription>
    <Details>
<![CDATA[
  <p>对已装箱的值进行取消装箱，然后立即重新装箱
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION">
    <ShortDescription>对原始值进行装箱，然后取消装箱以执行原语强制</ShortDescription>
<LongDescription>对基本值进行装箱，然后取消装箱以在{1}中执行图元强制</LongDescription>
    <Details>
<![CDATA[
  <p>构造的基元装箱值，然后立即转换为不同的基元类型(例如，<code>new double(D).intValue()<code>)。只需执行直接原语强制(例如，(Int)d).</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_BOXED_PRIMITIVE_TOSTRING">
    <ShortDescription>方法分配一个装箱的原语只是为了调用toString</ShortDescription>
<LongDescription>仅为调用{1}中的toString而装箱的图元</LongDescription>
    <Details>
<![CDATA[
  <p>分配装箱的基元仅用于调用toString()。只使用toString的静态形式更有效，它接受原始值。所以</p>
  <table>
     <tr><th>Replace...</th><th>With this...</th></tr>
     <tr><td>new Integer(1).toString()</td><td>Integer.toString(1)</td></tr>
     <tr><td>new Long(1).toString()</td><td>Long.toString(1)</td></tr>
     <tr><td>new Float(1.0).toString()</td><td>Float.toString(1.0)</td></tr>
     <tr><td>new Double(1.0).toString()</td><td>Double.toString(1.0)</td></tr>
     <tr><td>new Byte(1).toString()</td><td>Byte.toString(1)</td></tr>
     <tr><td>new Short(1).toString()</td><td>Short.toString(1)</td></tr>
     <tr><td>new Boolean(true).toString()</td><td>Boolean.toString(true)</td></tr>
  </table>
]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_PARSING">
    <ShortDescription>boxingunboxing解析原语</ShortDescription>
<LongDescription>Boxingunboxing以解析基元{1}</LongDescription>
    <Details>
<![CDATA[
  <p>从字符串创建装箱的基元，只是为了提取未装箱的基元值。只调用静态parseXXX方法更有效.</p>
]]>
    </Details>
  </BugPattern>
    <BugPattern type="DM_BOXED_PRIMITIVE_FOR_COMPARE">
   <ShortDescription>对原语进行装箱以进行比较</ShortDescription>
<LongDescription>原语已装箱以调用{2}：改用{3}</LongDescription>
    <Details>
<![CDATA[
  <p>创建装箱的基元只是为了调用compareto方法。使用静态比较方法(从Java 1.4开始用于Double和Float，对于自Java 1.7以来的其他基元类型)更有效，它直接作用于基元
  </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEW_FOR_GETCLASS">
    <ShortDescription>方法分配一个对象，只是为了获取类对象</ShortDescription>
<LongDescription>{1}分配对象，只是为了获取类对象</LongDescription>
    <Details>
<![CDATA[
  <p>此方法分配对象只是为了对其调用getclass()，以便为其检索Class对象。只访问类的.class属性会更简单.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_MONITOR_WAIT_ON_CONDITION">
    <ShortDescription>monitor wait()在条件下调用</ShortDescription>
<LongDescription>针对{1}中的条件调用了monitor wait()</LongDescription>
    <Details>
      <![CDATA[
      <p>
     此方法在<code>java.util.concurrent.locks.Condition<code>对象上调用<code>wait()<code>。
     等待<code>条件<code>应使用由<code>条件<code>接口定义的<code>await()<code>方法之一来完成
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_01_TO_INT">
   <ShortDescription>从0到1的随机值强制为整数0</ShortDescription>
<LongDescription>{1}使用生成从0到1的随机值，然后强制将该值强制为整数0</LongDescription>
    <Details>
<![CDATA[
  <p>0到1之间的随机值被强制为整数值0。您可能希望在将随机值强制为整数之前将其乘以其他值，或者使用<code>Random.nextInt(N)<code>方法
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_INVALID_MIN_MAX">
   <ShortDescription>Math.max和Math.min的组合不正确</ShortDescription>
<LongDescription>Math.max和Math.min的组合不正确：此代码始终返回{2}</LongDescription>
    <Details>
<![CDATA[
  <p>此代码尝试使用Math.min(0，Math.max(100，value)这样的构造来限制值边界。但是常量的顺序不正确：它应该是Math.min(100，Math.max(0，value)。
  因此，此代码始终生成相同的结果(如果值为NaN，则为NaN).</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_NEXTINT_VIA_NEXTDOUBLE">
    <ShortDescription>使用Random的nextInt方法而不是nextDouble生成随机整数</ShortDescription>
<LongDescription>{1}使用Random的nextDouble方法生成随机整数；使用nextInt更有效</LongDescription>
    <Details>
<![CDATA[
  <p>如果<code>r<code>是<code>java.util.Random<code>，则可以使用<code>r.nextInt(N)<code>生成从<code>0<code>到<code>n-1的随机数，而不是使用<code>(Int)(r.nextDouble()*n)<code>
</p>
<p>nextInt的参数必须为正。例如，如果希望生成一个从-99到0的随机值，请使用<code>-r.nextInt(100)<code>
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE">
   <ShortDescription>传递给SQL语句的Execute或addBatch方法的非常量字符串</ShortDescription>
<LongDescription>{1}将非常量字符串传递给SQL语句的execute或addBatch方法</LongDescription>
    <Details>
<![CDATA[
  <p>该方法使用似乎是动态生成的字符串对SQL语句调用execute或addBatch方法。请考虑改用预准备语句。它的效率更高，不易受到SQL注入攻击
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING">
    <ShortDescription>准备好的语句是从非常量字符串生成的</ShortDescription>
<LongDescription>从{1}中的非常量字符串生成预准备语句</LongDescription>
    <Details>
<![CDATA[
  <p>代码从非常量字符串创建SQL准备好的语句。如果未选中，则在构建此字符串时将使用来自用户的受污染数据，SQL注入可用于使准备好的语句做一些意外和不希望发生的事情.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DM_USELESS_THREAD">
    <ShortDescription>线程是使用默认的空运行方法创建的</ShortDescription>
<LongDescription>{1}使用默认的空运行方法创建线程</LongDescription>
    <Details>
<![CDATA[
  <p>此方法通过从Thread类派生或通过传递Runnable对象来创建线程，而不指定Run方法。那么，这个线程除了浪费时间什么也不做
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_DOUBLECHECK">
  <ShortDescription>可能对字段进行双重检查</ShortDescription>
<LongDescription>{1}中的{2}上可能存在双重检查</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法可能包含双重检查锁定的实例。根据Java内存模型的语义，此习惯用法不正确。有关详细信息，请参阅网页：
  <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html"
  >http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DC_PARTIALLY_CONSTRUCTED">
    <ShortDescription>部分初始化对象的可能曝光</ShortDescription>
<LongDescription>{1}中部分初始化的对象可能暴露</LongDescription>
    <Details>
<![CDATA[
  <p>看起来此方法使用带有双重检查锁定的惰性字段初始化。虽然字段被正确声明为volatile，但对象的内部结构可能在字段赋值后发生更改，因此另一个线程可能会看到部分初始化的对象</p>
  <p>若要解决此问题，请考虑先将对象存储到局部变量中，并仅在完全构造后将其保存到volatile字段中
  </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_NULLS_FIELDS">
   <ShortDescription>终结器NULL字段</ShortDescription>
<LongDescription>{3}在{1.class}中的Finalize方法内设置为NULL</LongDescription>
    <Details>
<![CDATA[
  <p> 此终结器将字段清空。这通常是一个错误，因为它不有助于垃圾收集，而且对象无论如何都会被垃圾收集.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_FINALIZER_ONLY_NULLS_FIELDS">
    <ShortDescription>终结器仅为空字段</ShortDescription>
<LongDescription>{1}仅为空字段</LongDescription>
    <Details>
<![CDATA[
  <p> 此终结器除了空出字段外什么也不做。这是完全没有意义的，并且需要对象进行垃圾收集、最终确定，然后再次进行垃圾收集。您应该删除Finalize方法
.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_PUBLIC_SHOULD_BE_PROTECTED">
    <ShortDescription>终结器应该受到保护，而不是公共</ShortDescription>
<LongDescription>{1}是公共的；应该受到保护</LongDescription>
    <Details>
<![CDATA[
  <p> 类的<code>finalize()<code>方法应该具有受保护的访问权限，而不是public.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EMPTY">
    <ShortDescription>应删除空的终结器</ShortDescription>
<LongDescription>{1}为空，应删除</LongDescription>
    <Details>
<![CDATA[
  <p> 空<code>finalize()<code>方法无用，因此应将其删除.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_NULLIFY_SUPER">
    <ShortDescription>终结器使超类终结器无效</ShortDescription>
<LongDescription>{1}正在使{2}.finalize()无效；这是有意的吗？</LongDescription>
    <Details>
<![CDATA[
  <p> 此空的<code>finalize()<code>方法显式否定由其超类定义的任何终结器的效果。
  将不会执行为超类定义的任何终结器操作。
  除非有意这样做，否则请删除此方法.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_USELESS">
   <ShortDescription>终结器只调用超类终结器</ShortDescription>
<LongDescription>{1}除了调用super.finalize()外什么也不做；删除它</LongDescription>
    <Details>
<![CDATA[
  <p> <code>finalize()<code>方法所做的唯一事情是调用超类的<code>finalize()<code>方法，使其成为冗余方法。&nbsp；删除它.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_MISSING_SUPER_CALL">
    <ShortDescription>终结器不调用超类终结器</ShortDescription>
<LongDescription>{1}缺少对super.finalize()的调用，因此{2}.finalize()未被调用</LongDescription>
    <Details>
<![CDATA[
  <p> 此<code>finalize()<code>方法不调用其超类的<code>finalize()<code>方法。
  因此，不会执行为超类定义的任何终结器操作。
  添加对<code>super.finalize()的调用.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="FI_EXPLICIT_INVOCATION">
 <ShortDescription>终结器的显式调用</ShortDescription>
<LongDescription>在{1}中显式调用{2}</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法包含对象的<code>finalize()<code>方法的显式调用。
  因为终结器方法应该只执行一次，并且只能由VM执行，这是一个不好的主意.</p>
<p>如果连接的一组对象可执行finalize，则VM将对所有finalizable对象调用finalize方法，可能会同时在不同的线程中执行。
   因此，在类X的Finalize方法中，对X引用的对象调用Finalize是一个特别糟糕的想法，因为它们可能已经在单独的线程中完成.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS">
    <ShortDescription>等于检查不兼容的操作数</ShortDescription>
<LongDescription>{1}检查操作数是否为{2.givenClass}</LongDescription>
    <Details>
<![CDATA[
  <p>该equals方法正在检查参数是否为某种不兼容的类型(即，一个既不是定义equals方法的类的超类型也不是子类型的类)。
  例如，foo类可能有一个equals方法，它看起来像：
</p>
<pre>
public boolean equals(Object o) {
  if (o instanceof Foo)
    return name.equals(((Foo)o).name);
  else if (o instanceof String)
    return name.equals(o);
  else return false;
</pre>

<p>这被认为是不好的做法，因为它使实现对称和可传递的equals方法变得非常困难。如果没有这些属性，可能会出现非常意外的行为
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DONT_DEFINE_EQUALS_FOR_ENUM">
   <ShortDescription>为枚举定义的协变量equals()方法</ShortDescription>
<LongDescription>枚举{0}定义等于({0.givenClass})</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义枚举，枚举上的等式是使用对象标识定义的。
  为枚举值定义协变等于方法是非常糟糕的做法，因为这可能会导致两个不同的枚举值使用协变枚举方法作为相等进行比较，并且在正常比较时不相等。
  别这么做
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_USE_OBJECT">
    <ShortDescription>定义了协变equals()方法，继承了Object.equals(Object)</ShortDescription>
<LongDescription>
{0}定义equals({0.givenClass})方法并使用Object.equals(Object)
</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义<code> equals（）</ code>方法的协变版本，但继承了基本<code> java.lang.
  Object中定义的普通<code> equals（Object）</ code>方法</ 代码>类。
  该类应该定义一个<code> boolean equals（Object）</ code>方法。
  </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_USE_OBJECT">
    <ShortDescription>定义的equals（）方法不会覆盖Object.equals（Object）</ShortDescription>
    <LongDescription>{0}定义{1.givenClass}方法并使用Object.equals（Object）</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了<code>equals()<code>方法的协变版本，但继承了基础<code>java.lang.Object<code>类中定义的普通<code>equals(Object)<code>方法。
  该类可能应该定义<code>boolean equals(Object)<code>方法
  </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OTHER_NO_OBJECT">
    <ShortDescription>equals()方法定义的不重写Object.equals(Object)的方法</ShortDescription>
<LongDescription>{0}定义{1.givenClass}方法并使用Object.equals(Object)</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了<code>equals()<code>方法，该方法不覆盖基<code>java.lang.Object<code>类中定义的普通<code>equals(Object)<code>方法。
  该类可能应该定义<code>boolean equals(Object)<code>方法
  </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_DOESNT_OVERRIDE_EQUALS">
   <ShortDescription>类不重写超类中的等于</ShortDescription>
<LongDescription>{0}不覆盖{2.givenClass}</LongDescription>
    <Details>
<![CDATA[
  <p>此类扩展了定义equals方法并添加字段的类，但不定义equals方法本身。
  因此，此类实例上的相等将忽略子类和添加的字段的标识。确保这就是您想要的，并且您不需要重写equals方法。
  即使不需要重写equals方法，也可以考虑重写它，以证明子类的equals方法只返回调用super.equals(O)的结果.
  </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_SELF_NO_OBJECT">
   <ShortDescription>定义的协变equals()方法</ShortDescription>
<LongDescription>{0}定义equals({0.givenClass})方法，但不定义equals(Object)方法</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了<code>equals()<code>的协变版本。
  若要正确覆盖<code>java.lang.Object<code>中的<code>equals()方法，<code>equals()的参数必须具有<code>java.lang.Object<code>类型.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC">
    <ShortDescription>equals方法重写超类中的equals，并且可能不对称</ShortDescription>
<LongDescription>{1.class}覆盖{2.class.givenClass}中的等于，并且可能不对称</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了一个覆盖超类中的equals方法的equals方法。两个equals方法都使用<code>instanceof<code>来确定两个对象是否相等。
  这充满了危险，因为equals方法必须是对称的(换句话说，<code>a.equals(B)=b.equals(A)<code>)。
  如果B是A的子类型，并且A的equals方法检查参数是A的instanceof，而B的equals方法检查参数是instanceof B，则这些方法定义的等价关系很可能不对称.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_GETCLASS_AND_CLASS_CONSTANT">
    <ShortDescription>对子类型，equals方法失败</ShortDescription>
<LongDescription>{1}为子类型失败</LongDescription>
    <Details>
<![CDATA[
  <p> 此类具有equals方法，如果子类继承该方法，则该方法将被破坏。
  它将类文字与参数的类进行比较(例如，在class<code>foo<code>中，它可能检查<code>foo.class=o.getClass()<code>)。
  最好检查<code>this.getClass()=o.getClass()<code>
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_UNUSUAL">
    <ShortDescription>异常等值法</ShortDescription>
<LongDescription>{1}不寻常</LongDescription>
    <Details>
<![CDATA[
  <p> 此类不执行我们识别的任何模式，用于检查参数的类型是否与<code>this<code>对象的类型兼容。
      这段代码可能没有任何问题，但值得一看
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARING_CLASS_NAMES">
    <ShortDescription>equals方法比较类名而不是类对象</ShortDescription>
<LongDescription>{1}比较类名而不是类对象</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法通过检查两个对象的类名称是否相等来检查两个对象是否是相同的类。
  如果不同的类加载器加载不同的类，则可以有相同名称的不同类。只是检查一下类对象是否相同
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_TRUE">
   <ShortDescription>equals方法始终返回true</ShortDescription>
<LongDescription>{1}始终返回TRUE</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了一个始终返回true的equals方法。这很有想象力，但不是很聪明。另外，这意味着等于方法是不对称的
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ALWAYS_FALSE">
    <ShortDescription>equals方法总是返回false</ShortDescription>
<LongDescription>{1}始终返回FALSE</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了一个始终返回false的equals方法。这意味着一个对象不等于它自己，并且不可能创建这个类的有用的Maps或Set。
  更根本的是，它意味着equals不是自反的，这是equals方法的要求之一</p>
<pre>
可能预期的语义是对象标识：对象等于自身。这是从class<code>object<code>继承的行为。如果需要重写从不同超类继承的equals，可以使用use：<p><pre>public boolean equals(Object O){return this=o；}
</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HSC_HUGE_SHARED_STRING_CONSTANT">
    <ShortDescription>巨大的字符串常量在多个类文件中重复</ShortDescription>
    <LongDescription>{1}初始化为字符串常量{2}字符长，在{3}其他类文件中重复。</LongDescription>
   
    <Details>
      <![CDATA[
      <p>
    一个大的String常量在多个类文件中重复。
    这可能是因为final字段初始化为String常量，而Java语言要求将对来自其他类的final字段的所有引用内联到该类文件中。 
    在 <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6447475">JDK bug 6447475</a> 中查找
    有关JDK中此错误发生的描述以及解析它如何将JDK的大小减少1兆字节
</p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_ARGUMENT_MIGHT_BE_NULL">
   <ShortDescription>方法不检查空参数</ShortDescription>
<LongDescription>{1}不检查NULL参数</LongDescription>
    <Details>
      <![CDATA[
      <p>
    已将此方法的参数标识为应始终检查的值，以查看它是否为NULL，但正在取消引用，而不进行前面的NULL检查
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT">
    <ShortDescription>equals()方法不检查null参数</ShortDescription>
<LongDescription>{1}不检查NULL参数</LongDescription>
    <Details>
      <![CDATA[
      <p>
      equals(Object)的这种实现违反了java.lang.Object.equals()定义的协定，因为它不检查作为参数传递的null。
      如果传递空值，则所有equals()方法都应返回false
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="RV_NEGATING_RESULT_OF_COMPARETO">
   <ShortDescription>否定compareto()Compare()的结果</ShortDescription>
<LongDescription>{1}取反{2}的返回值</LongDescription>
    <Details>
<![CDATA[
  <p>此代码取反compareto或Compare方法的返回值。这是一个有问题或不好的编程实践，因为如果返回值是Integer.MIN_VALUE，取反返回值不会否定结果的符号。
  您可以通过颠倒操作数的顺序而不是否定结果来获得相同的预期结果
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_RESULTS_MIN_VALUE">
    <ShortDescription>compareto()Compare()返回Integer.MIN_VALUE</ShortDescription>
<LongDescription>{1}返回Integer.MIN_VALUE，不能取反</LongDescription>
    <Details>
<![CDATA[
  <p> 在某些情况下，此compareto或Compare方法返回常量Integer.MIN_VALUE，这是一种异常糟糕的做法。
  compareto的返回值唯一重要的是结果的符号。但是人们有时会否定compareto的返回值，期望这会否定结果的符号。
  它会的，除非返回值是Integer.MIN_VALUE。
  所以只返回-1而不是Integer.MIN_VALUE
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_COMPARETO_INCORRECT_FLOATING">
    <ShortDescription>compareto()Compare()错误地处理浮点值或双精度值</ShortDescription>
<LongDescription>{1}错误地处理{2}值</LongDescription>
    <Details>
<![CDATA[
  <p>此方法使用如下模式比较double或float值：val1&gt；val2？1：val1&lt；val2？-1：0。此模式不适用于-0.0和NaN值，
  这可能会导致不正确的排序结果或损坏的集合(如果将比较的值用作键)。
  考虑使用Double.Compare或Float.Compare静态方法，这些方法可以正确处理所有特殊情况</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_SELF_NO_OBJECT">
    <ShortDescription>定义了协变compareto()方法</ShortDescription>
<LongDescription>
{0}定义compareto({0.givenClass})方法，但未定义compareto(Object)方法
</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了<code>compareto()<code>的协变版本。
  若要在<code>可比<code>接口中正确覆盖<code>compareto()<code>方法，<code>compareto()<code>的参数必须具有<code>java.lang.Object<code>类型</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS">
   <ShortDescription>Signature声明在散列构造中使用不可散列的类</ShortDescription>
<LongDescription>{2}未定义hashCode()方法，但它在{1}中的散列上下文中使用</LongDescription>
    <Details>
<![CDATA[
  <p> 方法、字段或类声明泛型签名，其中在需要Hashable类的上下文中使用非Hashable类。
  声明equals方法但从Object继承hashCode()方法的类是不可hash的，因为它不满足相等对象具有相等hashCode的要求
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_USE_OF_UNHASHABLE_CLASS">
   <ShortDescription>在散列数据结构中使用没有hashCode()方法的类</ShortDescription>
<LongDescription>{2}未定义hashCode()方法，但在{1}中的哈希数据结构中使用</LongDescription>
    <Details>
<![CDATA[
  <p>类定义了equals(Object)方法而不是hashCode()方法，因此不能满足相等对象具有相等hashCodes的要求。
  此类的一个实例用于哈希数据结构中，因此需要修复这个问题具有最高的重要性
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_USE_OBJECT_EQUALS">
    <ShortDescription>类定义hashCode()并使用Object.equals()</ShortDescription>
<LongDescription>{0}定义hashCode并使用Object.equals()</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义<code> hashCode（）</ code>方法，但从<code> java.lang.Object </ code>（通过比较对象引用定义相等性）继承其<code> equals（）</ code>方法 虽然这可能会满足合同，
  相等的对象必须具有相同的哈希码，但它可能不是通过覆盖<code> hashCode（）</ code>方法所预期的。
  （重写<code> hashCode（）</ code>意味着对象的标识基于比简单引用相等更复杂的标准。）</p>
<p>如果你认为这个类的实例不会被插入到HashMap / HashTable中，那么推荐使用的<code> hashCode </ code>实现是：</p>
<pre>public int hashCode() {
  assert false : "hashCode not designed";
  return 42; // any arbitrary constant will do
  }</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_COMPARETO_USE_OBJECT_EQUALS">
    <ShortDescription>类定义compareto(.)并使用Object.equals()</ShortDescription>
<LongDescription>{0}定义{1.givenClass}并使用Object.equals()</LongDescription>
    <Details>
<![CDATA[
  <p>此类定义<code> compareTo（...）</ code>方法，但从<code> java.lang.Object </ code>继承其<code> equals（）</ code>方法。
  一般来说，该值 当且仅当equals返回true时，compareTo才应返回零。 如果违反了此规则，则会在诸如PriorityQueue之类的类中发生奇怪且不可预测的故障。
     在Java 5中，PriorityQueue.remove方法使用compareTo方法，而在Java 6中，它使用equals方法。</p>

<p>从Comparable接口中的compareTo方法的JavaDoc：
<blockquote>
强烈建议，但不严格要求 <code>(x.compareTo(y)==0) == (x.equals(y))</code>.
一般来说，任何实现Comparable接口并且违反此条件的类都应该清楚地表明这一事实。 推荐的语言是“注意：此类具有与equals不一致的自然顺序。”
</blockquote></p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_HASHCODE_NO_EQUALS">
<ShortDescription>类定义hashCode()但不等于()</ShortDescription>
<LongDescription>{0}定义hashCode但不等于</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了<code>hashCode()<code>方法，但不是<code>equals()<code>方法。
  因此，该类可能违反相等对象必须具有相等hashcode的不变量.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_USE_HASHCODE">
    <ShortDescription>类定义equals()并使用Object.hashCode()</ShortDescription>
<LongDescription>{0}定义等于并使用Object.hashCode()</LongDescription>
    <Details>
<![CDATA[
  <p> 此类重写<code> equals（Object）</ code>，
  但不覆盖<code> hashCode（）</ code>，并从<code> java继承<code> hashCode（）</ code>的实现 .lang.Object </ code>（返回标识哈希码，由VM分配给对象的任意值）
  因此，该类很可能违反了等于对象必须具有相等哈希码的不变量。</p>

<p>如果你认为这个类的实例不会被插入到HashMap / HashTable中，那么推荐使用的<code> hashCode </ code>实现是：</p>
<pre>public int hashCode() {
  assert false : "hashCode not designed";
  return 42; // any arbitrary constant will do
  }</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_INHERITS_EQUALS_USE_HASHCODE">
   <ShortDescription>类继承equals()并使用Object.hashCode()</ShortDescription>
<LongDescription>{0}继承equals并使用Object.hashCode()</LongDescription>
    <Details>
<![CDATA[
  <p> 此类从抽象超类继承<code> equals（Object）</ code>，从<code> java.lang.Object </ code>继承<code> hashCode（）</ code>
  （返回标识哈希码 ，由VM分配给对象的任意值。
   因此，该类很可能违反了相等对象必须具有相同哈希码的不变量。</p>

  <p>如果您不想定义hashCode方法，并且/或者不相信该对象将被放入HashMap / Hashtable，请定义<code> hashCode（）</ code>方法以抛出<code> UnsupportedOperationException</代码>。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="HE_EQUALS_NO_HASHCODE">
    <ShortDescription>类定义equals()，但不定义hashCode()</ShortDescription>
<LongDescription>{0}定义equals，但不定义hashCode</LongDescription>
    <Details>
<![CDATA[
  <p> 此类重写<code>equals(Object)<code>，但不重写<code>hashCode()<code>。
      因此，该类可能违反相等对象必须具有相等hashcode的不变量.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EQ_ABSTRACT_SELF">
    <ShortDescription>抽象类定义协变equals()方法</ShortDescription>
<LongDescription>摘要{0}定义equals({0.givenClass})方法</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了<code>equals()<code>的协变版本。
      若要正确覆盖<code>java.lang.Object<code>中的<code>equals()方法，<code>equals()的参数必须具有<code>java.lang.Object<code>类型</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_STRINGS_WITH_EQ">
    <ShortDescription>使用=或！=比较字符串对象</ShortDescription>
<LongDescription>在{1}中使用=或！=比较字符串对象</LongDescription>
    <Details>
<![CDATA[
  <p>此代码使用=或！=运算符比较<code>java.lang.String<code>对象的引用相等。
  除非两个字符串都是源文件中的常量，或者已经使用<code>String.intern()<code>方法访问过，否则相同的字符串值可以由两个不同的String对象表示。
  请考虑改用<code>equals(Object)<code>方法。.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ES_COMPARING_PARAMETER_STRING_WITH_EQ">
   <ShortDescription>使用=或！=比较字符串参数</ShortDescription>
<LongDescription>在{1}中使用=或！=比较字符串参数</LongDescription>
    <Details>
<![CDATA[
  <p>此代码使用=或！=运算符比较<code>java.lang.String<code>参数的引用相等。
  要求调用方仅将字符串常量或中间字符串传递给方法是不必要的脆弱，并且很少会导致可测量的性能提升。
  请考虑改用<code>equals(Object)<code>方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CO_ABSTRACT_SELF">
    <ShortDescription>抽象类定义协变compareto()方法</ShortDescription>
<LongDescription>摘要{0}定义compareto({0.givenClass})方法</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了<code>compareto()<code>的协变版本。
  若要在<code>可比<code>接口中正确覆盖<code>compareto()<code>方法，<code>compareto()<code>的参数必须具有<code>java.lang.Object<code>类型.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_FIELD_NOT_GUARDED">
    <ShortDescription>未防范并发访问的字段</ShortDescription>
<LongDescription>{1.givenClass}未防范并发访问；已锁定{2}%的时间</LongDescription>
    <Details>
<![CDATA[
  <p> 此字段使用net.jcip.annotations.GuardedBy或javax.annotation.concurrent.GuardedBy进行批注，但访问方式似乎违反了这些批注.</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="MSF_MUTABLE_SERVLET_FIELD">
   <ShortDescription>可变servlet字段</ShortDescription>
<LongDescription>{1}是可变的Servlet字段</LongDescription>
<Details>
<![CDATA[
<p>Web服务器通常只创建Servlet或jsp类的一个实例(即将该类视为Singleton)，并将有多个线程调用该实例上的方法以服务于多个并发请求。
因此，具有可变实例字段通常会产生竞争条件。.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS2_INCONSISTENT_SYNC">
    <ShortDescription>不一致同步</ShortDescription>
<LongDescription>{1}的同步不一致；锁定了{2}%的时间</LongDescription>
    <Details>
<![CDATA[
  <p> 这个类的字段似乎在同步方面不一致。这个错误报告表明错误模式检测器判断出来了
  </p>
  <ul>
  <li> 该类包含锁定和未锁定访问的混合，</li>
  <li>该类<b>不</ b>注释为javax.annotation.concurrent.NotThreadSafe，</li>
  <li> 至少有一个锁定访问是由类自己的方法之一执行的，并且</li>
  <li>非同步字段访问（读取和写入）的数量不超过所有访问的三分之一，写入的权重是读取的两倍</li>
  </ul>

  <p> 匹配此错误模式的典型错误是忘记同步一个用于线程安全的类中的方法之一。</p>

  <p>您可以选择标记为“非同步访问”的节点，以显示检测器认为未经同步访问字段的代码位置。</p>

  <p> 请注意，此探测器存在各种不准确的原因; 
  例如，探测器无法静态检测到锁定的所有情况。
  而且，即使检测器准确区分锁定访问和未锁定访问，所讨论的代码仍然可能是正确的。</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="NN_NAKED_NOTIFY">
   <ShortDescription>裸露通知</ShortDescription>
<LongDescription>{1}中的裸露通知</LongDescription>
    <Details>
<![CDATA[
  <p> 调用<code>Notify()<code>或<code>NotifyAll()时没有伴随对可变对象状态的任何(明显的)修改。&nbsp；通常，在监视器上调用Notify方法是因为另一个线程正在等待的某个条件已变为真。
  但是，要使该条件有意义，它必须涉及对两个线程都可见的堆对象</p>

  <p> 此错误不一定表示错误，因为可变对象状态的更改可能发生在方法中，该方法随后调用包含通知的方法。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_EXPOSE_REP">
   <ShortDescription>公共静态方法可以通过返回数组来公开内部表示</ShortDescription>
<LongDescription>public static{1}可能通过返回{2.givenClass}公开内部表示</LongDescription>
    <Details>
<![CDATA[
  <p> 公共静态方法返回对属于类静态一部分的数组的引用。调用此方法的任何代码都可以自由修改基础数组。
      一种修复方法是返回数组的副本.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP">
   <ShortDescription>可以通过返回对可变对象的引用来公开内部表示</ShortDescription>
<LongDescription>{1}可能通过返回{2.givenClass}公开内部表示</LongDescription>
    <Details>
<![CDATA[
  <p> 返回对存储在对象的一个字段中的可变对象值的引用会暴露该对象的内部表示形式。
  如果实例由不受信任的代码访问，并且对可变对象的未经检查的更改会危及安全性或其他重要属性，则需要采取不同的措施。
  在许多情况下，返回对象的新副本是更好的方法.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_REP2">
    <ShortDescription>可以通过合并对可变对象的引用来公开内部表示</ShortDescription>
<LongDescription>{1}可以通过将外部可变对象存储到{2.givenClass}中来公开内部表示</LongDescription>
    <Details>
<![CDATA[
  <p> 此代码将对外部可变对象的引用存储到对象的内部表示形式中。
  如果实例由不受信任的代码访问，并且对可变对象的未经检查的更改会危及安全性或其他重要属性，则需要采取不同的措施。在许多情况下，存储对象的副本是更好的方法。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EI_EXPOSE_STATIC_REP2">
    <ShortDescription>可以通过将可变对象存储到静态字段中来暴露内部静态</ShortDescription>
<LongDescription>{1}可能通过将可变对象存储到静态字段中来暴露内部静态{2}</LongDescription>
    <Details>
<![CDATA[
  <p> 此代码将对外部可变对象的引用存储到静态字段中。如果对可变对象的未经检查的更改会危及安全性或其他重要属性，您将需要做一些不同的事情。
  在许多情况下，存储对象的副本是更好的方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RU_INVOKE_RUN">
    <ShortDescription>调用在线程上运行(您的意思是改为启动它吗？)</ShortDescription>
<LongDescription>{1}显式调用线程上的run(您的意思是改为启动它吗？)</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法显式调用对象上的<code>run()<code>。
      通常，类实现<code>runnable<code>接口，因为它们将在新线程中调用其<code>run()<code>方法，在这种情况下，<code>Thread.start()<code>是要调用的正确方法.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SP_SPIN_ON_FIELD">
   <ShortDescription>方法在字段上旋转</ShortDescription>
<LongDescription>在{1}中的{2.givenClass}上旋转</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法在读取字段的循环中旋转。&nbsp；编译器可以合法地提升对循环的读取，从而将代码转换为无限循环。
     应更改类，以便它使用正确的同步(包括Wait和Notify调用).</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_DANGEROUS_NON_SHORT_CIRCUIT">
   <ShortDescription>非短路逻辑的潜在危险使用</ShortDescription>
<LongDescription>{1}中非短路逻辑的潜在危险使用</LongDescription>
    <Details>
<![CDATA[
  <p> 该代码似乎使用非短路逻辑（例如，或|）而不是短路逻辑（;或||）。 
  此外，根据左侧的值，您可能不希望评估右侧（因为它会产生副作用，可能导致异常或可能很昂贵）。</p>
<p>
即使从了解左侧可以推断出结果，非短路逻辑也会导致表达式的两侧被评估。
 这可能效率较低，并且如果在评估右侧时左侧防护案例可能产生错误，则可能导致错误。
</p>

<p>See <a href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2">the Java
Language Specification</a> for details

</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NS_NON_SHORT_CIRCUIT">
    <ShortDescription>非短路逻辑的使用有问题</ShortDescription>
<LongDescription>{1}中非短路逻辑的使用有问题</LongDescription>
    <Details>
<![CDATA[
  <p> 该代码似乎使用非短路逻辑（例如，或|）而不是短路逻辑（＆amp;＆amp;或||）。
即使从了解左侧可以推断出结果，非短路逻辑也会导致表达式的两侧被评估。
 这可能效率较低，并且如果在评估右侧时左侧防护案例可能产生错误，则可能导致错误。

<p>在 <a href="http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.22.2">the Java
Language Specification</a> 上查看详细信息

</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_WAIT">
  <ShortDescription>按住两个锁等待</ShortDescription>
<LongDescription>wait()，在{1}中持有两个锁</LongDescription>
    <Details>
<![CDATA[
  <p>在保持两个锁的情况下等待监视器可能会导致死锁。
  执行等待只释放正在等待的对象上的锁，而不是任何其他锁。
  这不一定是一个bug，但值得仔细检查。.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="TLW_TWO_LOCK_NOTIFY" deprecated="true">
    <!-- never generated -->
    <ShortDescription>保持两个锁的情况下进行通知</ShortDescription>
<LongDescription>Notify()或NotifyAll*()，在{1}中持有两个锁</LongDescription>
    <Details>
<![CDATA[
  <p> 当持有两个锁时，代码调用Notify()或NotifyAll()。
  如果此通知旨在唤醒持有相同锁的wait()，它可能会死锁，因为等待只会放弃一个锁，而通知将无法同时获得两个锁，因此通知将不会成功。
  如果还出现关于两个锁等待的警告，则错误的可能性相当高
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UW_UNCOND_WAIT">
    <ShortDescription>无条件等待</ShortDescription>
<LongDescription>{1}中的无条件等待</LongDescription>
    <Details>
<![CDATA[
  <p>此方法包含对<code>java.lang.Object.wait()的调用，该调用不受条件控制流的保护。
  在调用wait之前，代码应验证它要等待的条件尚未满足；将忽略以前的任何通知
  </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ">
    <ShortDescription>构造函数中字段的未初始化读取</ShortDescription>
<LongDescription>{1}中{2.name}的未初始化读取</LongDescription>
    <Details>
<![CDATA[
  <p> 此构造函数读取尚未赋值的字段。&
  这通常是由于程序员错误地使用了该字段而不是构造函数的某个参数.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR">
    <ShortDescription>从超类的构造函数调用的字段方法的未初始化读取</ShortDescription>
<LongDescription>从超类的构造函数调用时，{2.name}未在{1}中初始化</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法在超类的构造函数中调用。此时，类的字段尚未初始化。</p>
<p>为了更具体化，请考虑以下类s:</p>
<pre>abstract class A {
  int hashCode;
  abstract Object getValue();
  A() {
    hashCode = getValue().hashCode();
    }
  }
class B extends A {
  Object value;
  B(Object v) {
    this.value = v;
    }
  Object getValue() {
    return value;
  }
  }</pre>
<p>构造<code>B<code>时，在<code>B<code>的构造函数设置<code>值之前调用<code>A<code>类的构造函数。
因此，当<code>A<code>的构造函数调用<code>getValue<code>时，将读取<code>value<code><p>的未初始化值
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UG_SYNC_SET_UNSYNC_GET">
    <ShortDescription>不同步获取方法，同步设置方法</ShortDescription>
<LongDescription>{1}未同步，{2}已同步</LongDescription>
    <Details>
<![CDATA[
  <p> 此类包含名称类似的get和set方法，其中set方法是同步的，而get方法不是。
  这可能会导致运行时行为不正确，因为get方法的调用方不一定会看到对象的一致状态。
  应该使get方法同步</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_INIT_CIRCULARITY">
   <ShortDescription>初始化循环</ShortDescription>
<LongDescription>{0}和{1}之间的初始化循环</LongDescription>
    <Details>
<![CDATA[
  <p>在Bug实例引用的两个类的静态初始值设定项中检测到循环性。
  这种循环性可能会导致多种意外行为</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION">
    <ShortDescription>超类在初始化过程中使用子类</ShortDescription>
<LongDescription>{0}的初始化访问尚未初始化的类{2}</LongDescription>
    <Details>
<![CDATA[
  <p> 在类的初始化过程中，该类会主动使用子类。在使用时，该子类还不会初始化。例如，在下面的代码中，<code>foo<code>将为null.</p>

<pre>
public class CircularClassInitialization {
    static class InnerClassSingleton extends CircularClassInitialization {
        static InnerClassSingleton singleton = new InnerClassSingleton();
    }

    static CircularClassInitialization foo = InnerClassSingleton.singleton;
}
</pre>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="IT_NO_SUCH_ELEMENT">
    <ShortDescription>Iterator next()方法无法引发NoSuchElementException</ShortDescription>
<LongDescription>{1}无法引发NoSuchElementException</LongDescription>
    <Details>
<![CDATA[
  <p> 此类实现了<code>java.util.Iterator<code>接口。
  但是，它的<code><code>java.util.NoSuchElementException<code>.
  ()<code>方法无法引发Next。应该更改<code>next()<code>方法，以便在没有更多要返回的元素时调用时引发NoSuchElementException</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_SHARED_CONSTANT">
    <ShortDescription>网际字符串上的同步</ShortDescription>
<LongDescription>在{1}中对内联字符串进行同步</LongDescription>
    <Details>
<![CDATA[
  <p> The code synchronizes on interned String.</p>
<pre>
private static String LOCK = "LOCK";
...
  synchronized(LOCK) { ...}
...
</pre>
<p>常量字符串在JVM加载的所有其他类中实现并共享。 因此，这可能会锁定其他代码也可能锁定的内容。 这可能导致非常奇怪且难以诊断阻塞和死锁行为。
 在 <a href="http://www.javalobby.org/java/forums/t96352.html">http://www.javalobby.org/java/forums/t96352.html</a> and <a href="http://jira.codehaus.org/browse/JETTY-352">http://jira.codehaus.org/browse/JETTY-352</a>.
</p>
<p>See CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. Do not synchronize on objects that may be reused</a> 看更多信息.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOOLEAN">
    <ShortDescription>布尔同步</ShortDescription>
<LongDescription>在{1}中对布尔值进行同步</LongDescription>
    <Details>
      <![CDATA[
  <p> 代码在盒装基元常量上同步，例如布尔值。</p>
<pre>
private static Boolean inited = Boolean.FALSE;
...
  synchronized(inited) {
    if (!inited) {
       init();
       inited = Boolean.TRUE;
       }
     }
...
</pre>
<p>由于通常只存在两个布尔对象，因此该代码可能与其他无关代码在同一对象上同步，导致无响应并可能出现死锁</p>
<p>See CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. Do not synchronize on objects that may be reused</a> for more information.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE">
    <ShortDescription>盒装原始值的同步</ShortDescription>
<LongDescription>在{1}中的{2}上同步</LongDescription>
    <Details>
      <![CDATA[
  <p> 代码在明显非共享的盒装基元上进行同步，例如整数。</p>
<pre>
private static final Integer fileLock = new Integer(1);
...
  synchronized(fileLock) {
     .. do something ..
     }
...
</pre>
<p>在这段代码中，将fileLock重新声明为更好</p>
<pre>
private static final Object fileLock = new Object();
</pre>
<p>
现有的代码可能没问题，但它很混乱，
未来的重构，例如IntelliJ中的“删除Boxing”重构，可能会使用在整个JVM中共享的实体化Integer对象来取代它，从而导致非常混乱的行为和潜力僵局。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE">
    <ShortDescription>盒装原语上的同步</ShortDescription>
<LongDescription>在{1}中的{2}上同步</LongDescription>
    <Details>
      <![CDATA[
  <p> 代码在盒装原始常量（例如整数）上同步。</p>
<pre>
private static Integer count = 0;
...
  synchronized(count) {
     count++;
     }
...
</pre>
<p>由于可以缓存和共享Integer对象，因此该代码可以与其他不相关的代码在同一对象上进行同步，从而导致无响应并可能出现死锁</p>
<p>在CERT <a href="https://www.securecoding.cert.org/confluence/display/java/CON08-J.+Do+not+synchronize+on+objects+that+may+be+reused">CON08-J. Do not synchronize on objects that may be reused</a> 看更多信息.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ESync_EMPTY_SYNC">
    <ShortDescription>空同步块</ShortDescription>
<LongDescription>{1}中的空同步块</LongDescription>
    <Details>
<![CDATA[
  <p> 代码包含一个空的同步块：</p>
<pre>
synchronized() {}
</pre>
<p>空的同步块比大多数人认识到的要微妙得多，难以正确使用，并且空的同步块几乎从来都不是比不那么做作的解决方案更好的解决方案
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IS_INCONSISTENT_SYNC">
    <ShortDescription>不一致同步</ShortDescription>
<LongDescription>{1}的同步不一致；锁定了{2}%的时间</LongDescription>
    <Details>
<![CDATA[
  <p> 此类的字段在同步方面似乎访问不一致。&nbsp；此错误报告表明错误模式检测器判断
  </p>
  <ul>
  <li> 类包含锁定和未锁定访问的混合,</li>
  <li> 至少一个锁定访问是由类自己的方法之一执行的，并且</li>
  <li> 未同步字段访问(读和写)的数量不超过所有访问的三分之一，写操作的权重是读操作的两倍</li>
  </ul>

  <p> 匹配此错误模式的典型错误忘记同步一个错误例如，检测器无法静态检测持有锁的所有情况。
  此外，即使检测器准确地区分锁定访问和未锁定访问，所涉及的代码可能仍然是正确的</p>

  <p> 请注意，此探测器存在各种不准确的原因; 例如，检测器不能静态地检测保持锁定的所有情况。
      而且，即使检测器准确区分锁定访问和未锁定访问，所讨论的代码仍然可能是正确的。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD">
    <ShortDescription>在字段上同步，徒劳地试图保护该字段</ShortDescription>
<LongDescription>{2.givenClass}上的同步在徒劳地尝试保护它</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法在字段上进行同步，似乎是为了防止同时更新该字段。
  但是保护字段会锁定被引用的对象，而不是字段。
  这可能不能提供您需要的互斥，并且其他线程可能正在获得被引用对象上的锁(出于其他目的)。
  此模式的示例为：</p>
<pre>
private Long myNtfSeqNbrCounter = new Long(0);
private Long getNotificationSequenceNumber() {
     Long result = null;
     synchronized(myNtfSeqNbrCounter) {
         result = new Long(myNtfSeqNbrCounter.longValue() + 1);
         myNtfSeqNbrCounter = new Long(result.longValue());
     }
     return result;
 }
</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ML_SYNC_ON_UPDATED_FIELD">
    <ShortDescription>方法在更新的字段上同步</ShortDescription>
<LongDescription>{1}在更新的字段{2.givenClass}上同步</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法在从可变字段引用的对象上进行同步。
      这不太可能具有有用的语义，因为不同的线程可能在不同的对象上同步</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_OOI_PKGPROTECT">
    <ShortDescription>字段应移出接口并使包受到保护</ShortDescription>
<LongDescription>{1}应移出接口并使包受到保护</LongDescription>
    <Details>
<![CDATA[
<p>
 接口中定义的最终静态字段引用可变对象，如数组或哈希表。这个可变对象可能会被恶意代码更改，或者意外地从另一个包中更改。
 要解决此问题，需要将字段移动到类并使包受到保护，以避免此漏洞</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_FINAL_PKGPROTECT">
    <ShortDescription>字段应同时是最终字段和受包保护的字段</ShortDescription>
<LongDescription>{1}应同时受最终版本和软件包保护</LongDescription>
    <Details>
<![CDATA[
 <p>
   恶意代码或其他包中的意外情况可能会更改可变静态字段。
   可以将该字段设置为Package Protected，并将其设置为final以避免此漏洞.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_REFACTORED_TO_BE_FINAL">
    <ShortDescription>字段不是最终字段，但应该重构为最终字段</ShortDescription>
<LongDescription>{1}不是最终版本，但应重构为最终版本</LongDescription>
    <Details>
<![CDATA[
   <p>
此静态字段是公共的，但不是最终字段，可能会被恶意代码或其他程序包意外更改。
可以将该字段设为最终字段，以避免此漏洞。
但是，静态初始值设定项包含对字段的不止一次写入，因此这样做将需要一些重构
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_SHOULD_BE_FINAL">
    <ShortDescription>字段不是最终字段，但应该是最终字段</ShortDescription>
<LongDescription>{1}不是最终版本，但应该是最终版本</LongDescription>
    <Details>
<![CDATA[
   <p>
此静态字段是公共的，但不是最终字段，可能会被恶意代码或其他程序包意外更改。
可以将字段设为最终字段以避免此漏洞.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_PKGPROTECT">
   <ShortDescription>字段应受包保护</ShortDescription>
<LongDescription>{1}应受程序包保护</LongDescription>
    <Details>
<![CDATA[
  <p> 可变静态字段可能会被恶意代码或意外更改。可以将该字段设置为包保护，以避免此漏洞.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_HASHTABLE">
<ShortDescription>字段是可变哈希表</ShortDescription>
<LongDescription>{1}是可变哈希表</LongDescription>
    <Details>
<![CDATA[
 <p>最终静态字段引用哈希表（Hashtable），恶意代码或从其他包意外访问该字段。此代码可以自由修改哈希表的内容</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION">
 <ShortDescription>字段是可变集合</ShortDescription>
<LongDescription>{1}是可变集合</LongDescription>
    <Details>
<![CDATA[
 <p>将可变集合实例分配给最终静态字段，因此恶意代码或来自另一个包的意外更改可能会发生更改。考虑将此字段包装到Collections.unmodifiableSetListMapetc中。
 以避免此漏洞.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_COLLECTION_PKGPROTECT">
    <ShortDescription>字段是一个应受包保护的可变集合</ShortDescription>
<LongDescription>{1}是应受包保护的可变集合</LongDescription>
    <Details>
<![CDATA[
 <p>将可变集合实例分配给最终静态字段，因此恶意代码或来自另一个包的意外更改可能会发生更改。
 可以将该字段设置为包保护，以避免此漏洞。
 或者，您可以将此字段包装到Collections.unmodifiableSetListMapetc中。以避免此漏洞</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_MUTABLE_ARRAY">
   <ShortDescription>字段是可变数组</ShortDescription>
<LongDescription>{1}是可变数组</LongDescription>
    <Details>
<![CDATA[
<p> 最终静态字段引用数组，恶意代码或从其他包意外访问该字段。此代码可以自由修改数组的内容.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MS_CANNOT_BE_FINAL">
   <ShortDescription>字段不是最终字段，无法保护其免受恶意代码的攻击</ShortDescription>
<LongDescription>{1}不是最终版本，无法保护其免受恶意代码的攻击</LongDescription>
    <Details>
<![CDATA[
  <p>
 恶意代码或其他包中的意外情况可能会更改可变静态字段。
 遗憾的是，字段的使用方式不允许对此问题进行任何简单的修复</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_MUTABLE_ENUM_FIELD">
    <ShortDescription>枚举字段是公共的并且是可变的</ShortDescription>
<LongDescription>{1}字段是公共的并且是可变的</LongDescription>
    <Details>
<![CDATA[
  <p>在公共枚举内部定义了可变的公共字段，因此恶意代码或其他程序包中的意外可能会更改该字段。尽管可变枚举字段可以用于惰性初始化，但将它们暴露给外部世界是一种不好的做法。
  考虑将此字段声明为final AND or package-private</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ME_ENUM_FIELD_SETTER">
    <ShortDescription>public enum方法无条件设置其字段</ShortDescription>
<LongDescription>{1}无条件设置字段{2.name}</LongDescription>
    <Details>
<![CDATA[
  <p>在public enum中声明的此public方法无条件地设置enum字段，因此恶意代码或其他包意外更改此字段。尽管可变枚举字段可以用于惰性初始化，但将它们暴露给外部世界是一种不好的做法。
  考虑删除此方法或将其声明为package-private。.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD">
    <ShortDescription>对继承方法或外部方法的可能不明确的调用</ShortDescription>
<LongDescription>{1}中外部方法或继承方法{2}的调用可能不明确</LongDescription>
    <Details>
<![CDATA[
  <p>
内部类正在调用可以解析为继承方法或外部类中定义的方法。例如，调用<code>foo(17)<code>，这是在超类和外部方法中定义的。
通过Java语义，将解析为调用继承的方法，但这可能不是您想要的。
</p>
<p>如果您真的打算调用继承的方法，请通过调用super上的方法来调用它(例如Invoke super.foo(17)，
因此您的代码的其他读者和FindBugs都会明白您想要调用继承的方法，而不是外部类中的方法。
</p>
<p>如果调用<code>this.foo(17)<code>，则将调用继承的方法。
然而，由于FindBugs只查看类文件，它无法区分<code>this.foo(17)<code>和<code>foo(17)<code>的调用之间的区别，它仍然会抱怨潜在的不明确调用。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_SUPERCLASS">
    <ShortDescription>类名不应遮蔽超类的简单名称</ShortDescription>
<LongDescription>类名{0}隐藏了超类{1}的简单名称</LongDescription>
    <Details>
<![CDATA[
  <p> 此类的简单名称与其超类的名称相同，只是它的超类位于不同的包中(例如，<code>alpha.foo<code>扩展<code>beta.foo<code>)。
  这可能会特别令人困惑，造成许多情况，其中您必须查看import语句来解析引用，并创造了许多机会来意外地定义不覆盖其超类中的方法。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_SAME_SIMPLE_NAME_AS_INTERFACE">
   <ShortDescription>类名称不应隐藏已实现接口的简单名称</ShortDescription>
<LongDescription>类名{0}隐藏了实现的接口{1}的简单名称</LongDescription>
    <Details>
<![CDATA[
  <p> 此类接口的简单名称与实现扩展接口的名称相同，不同之处在于该接口位于不同的包中(例如，<code>alpha.foo<code>扩展<code>beta.foo<code>)。
  这可能会特别令人困惑，造成许多情况，其中您必须查看import语句来解析引用，并创造了许多机会来意外地定义不覆盖其超类中的方法
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NAMING_CONVENTION">
    <ShortDescription>类名称应以大写字母开头</ShortDescription>
<LongDescription>类名{0}不以大写字母开头</LongDescription>
    <Details>
<![CDATA[
  <p> 类名应该是名词，大小写混合，每个内部单词的第一个字母大写。
  尽量保持类名的简单和描述性。使用整字-避免首字母缩写词和缩写(除非缩写比长形式更广泛地使用，如URL或HTML)
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_NAMING_CONVENTION">
    <ShortDescription>方法名称应以小写字母开头</ShortDescription>
<LongDescription>方法名称{1}不以小写字母开头</LongDescription>
    <Details>
<![CDATA[
  <p>
方法应该是动词，第一个字母小写混合，每个内部单词的第一个字母大写
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_FIELD_NAMING_CONVENTION">
    <ShortDescription>字段名称应以小写字母开头</ShortDescription>
<LongDescription>字段名称{1}不以小写字母开头</LongDescription>
    <Details>
<![CDATA[
  <p>
非最终字段的名称应混合大小写，第一个字母小写，后续单词的第一个字母大写。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING">
    <ShortDescription>非常容易混淆的方法名称</ShortDescription>
<LongDescription>方法{1}和{3}非常混乱</LongDescription>
    <Details>
<![CDATA[
  <p> 引用的方法的名称仅在大小写方面不同。这是非常令人困惑的，因为如果大小写相同，那么其中一个方法会覆盖另一个方法
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_VERY_CONFUSING_INTENTIONAL">
  <ShortDescription>非常混乱的方法名称(但可能是有意的)</ShortDescription>
<LongDescription>具有方法{1}和{3}非常混乱(但可能是故意的)</LongDescription>
    <Details>
<![CDATA[
  <p> 引用的方法的名称仅在大小写方面不同。这是非常令人困惑的，因为如果大小写相同，那么其中一个方法会覆盖另一个方法。
  从其他方法的存在来看，似乎这两种方法的存在都是有意的，但肯定是令人困惑的。
  您应该努力消除其中一个，除非您由于API冻结而被迫同时拥有这两个
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE">
    <ShortDescription>方法没有重写超类中的方法，因为参数的包错误</ShortDescription>
<LongDescription>{1}不重写超类中的方法，因为参数类型{4}与超类参数类型{5}不匹配</LongDescription>
    <Details>
<![CDATA[
  <p> 子类中的方法不会覆盖超类中的类似方法，因为参数的类型与超类中相应参数的类型不完全匹配。比如说，如果你有：</p>

<blockquote>
<pre>
import alpha.Foo;
public class A {
  public int f(Foo x) { return 17; }
}
----
import beta.Foo;
public class B extends A {
  public int f(Foo x) { return 42; }
}
</pre>
</blockquote>

<p>类<code> B </ code>中定义的<code> f（Foo）</ code>方法不会覆盖在<code> A类中定义的<code> f（Foo）</ code>方法</ code>，
因为参数类型是来自不同包的<code> Foo </ code>。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_WRONG_PACKAGE_INTENTIONAL">
   <ShortDescription>方法没有重写超类中的方法，因为参数的包错误</ShortDescription>
<LongDescription>{1}不重写超类中的方法，因为参数类型{4}与超类参数类型{5}不匹配</LongDescription>
    <Details>
<![CDATA[
  <p> 子类中的方法不会覆盖超类中的类似方法，因为参数的类型与超类中相应参数的类型不完全匹配。For example，if you have：</p>

<blockquote>
<pre>
import alpha.Foo;
public class A {
  public int f(Foo x) { return 17; }
}
----
import beta.Foo;
public class B extends A {
  public int f(Foo x) { return 42; }
  public int f(alpha.Foo x) { return 27; }
}
</pre>
</blockquote>

<p>类<code> B </ code>中定义的<code> f（Foo）</ code>方法不会覆盖在<code> A类中定义的<code> f（Foo）</ code>方法</ code>，
因为参数类型是来自不同包的<code> Foo </ code>。
</p>

<p>在本例中，子类确实定义了一个具有与超类中的方法相同的签名的方法，因此这是可以理解的。然而，这样的方法特别容易混淆。
您应该强烈考虑删除或弃用具有相似但不完全相同签名的方法。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CONFUSING">
   <ShortDescription>混淆的方法名称</ShortDescription>
<LongDescription>方法{1}和{3}令人困惑</LongDescription>
    <Details>
<![CDATA[
  <p> 引用的方法的名称仅在大小写方面不同.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_METHOD_CONSTRUCTOR_CONFUSION">
    <ShortDescription>表观方法构造函数混淆</ShortDescription>
<LongDescription>{1}可能打算成为构造函数</LongDescription>
    <Details>
<![CDATA[
  <p> 此常规方法与它在其中定义的类同名。很可能这是为了成为一个构造函数。
  如果要将其用作构造函数，请删除void返回值的声明。如果您意外地定义了此方法，意识到错误，定义了正确的构造函数，但由于向后兼容而无法摆脱此方法，请弃用该方法。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_HASHCODE">
    <ShortDescription>类定义hashcode()；它应该是hashCode()吗？</ShortDescription>
<LongDescription>类{0}定义了hashcode()；它应该是hashCode()吗？</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了一个名为<code>hashcode()<code>的方法。
  此方法不会覆盖<code>java.lang.Object中的<code>hashCode()<code>方法，这可能就是我们想要的.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_LCASE_TOSTRING">
   <ShortDescription>类定义toString()；它应该是toString()吗？</ShortDescription>
<LongDescription>类{0}定义了toString()；它应该是toString()吗？</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了一个名为<code>tostring()<code>的方法。
  此方法不会覆盖<code>java.lang.Object中的<code>toString()<code>方法，这可能就是我们想要的.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_BAD_EQUAL">
   <ShortDescription>类定义了equals(Object)；它应该是Equals(Object)吗？</ShortDescription>
<LongDescription>类{0}定义了equals(Object)；它应该是Equals(Object)吗？</LongDescription>
    <Details>
<![CDATA[
<p>此类定义了一个方法<code>equals(Object)<code>。
此方法不覆盖<code>java.lang.Object中的<code>equals(Object)<code>方法，这可能就是我们想要的.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NM_CLASS_NOT_EXCEPTION">
    <ShortDescription>类不是从异常派生的，即使它是这样命名的</ShortDescription>
<LongDescription>类{0}不是从异常派生的，即使它是这样命名的</LongDescription>
    <Details>
<![CDATA[
<p> 此类不是从另一个异常派生的，而是以“Exception”结束。这会使此类的用户感到困惑.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RR_NOT_CHECKED">
    <ShortDescription>方法忽略InputStream.read()的结果</ShortDescription>
<LongDescription>{1}忽略{2}的结果</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法忽略<code>java.io.InputStream.read()的其中一个变体的返回值，该变量可以返回多个字节。
  如果未检查返回值，则调用方将无法正确处理读取的字节数少于调用方请求的情况。
  这是一种特别隐蔽的错误，因为在许多程序中，从输入流中读取的内容通常会读取所请求的全部数据，从而导致程序仅失败</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SR_NOT_CHECKED">
    <ShortDescription>方法忽略InputStream.Skip()的结果</ShortDescription>
<LongDescription>{1}忽略{2}的结果</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法忽略可以跳过多个字节的<code>java.io.InputStream.Skip()的返回值。
  如果未检查返回值，则调用方将无法正确处理跳过的字节数少于调用方请求的字节的情况。
  ；这是一种特别隐蔽的错误，因为在许多程序中，从输入流跳过通常确实会跳过所请求的全部数据，从而导致程序偶尔失败。
  但是，对于缓冲的流，SKIP()只会跳过缓冲区中的数据，并且经常无法跳过请求的字节数。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_IS_STATIC">
   <ShortDescription>readResolve方法不能声明为静态方法。</ShortDescription>
<LongDescription>{1}应声明为实例方法而不是静态方法</LongDescription>
    <Details>
<![CDATA[
  <p> 为了让序列化机制识别readResolve方法，不能将它声明为静态方法
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_PRIVATE_READ_RESOLVE_NOT_INHERITED">
    <ShortDescription>私有readResolve方法未被子类继承</ShortDescription>
<LongDescription>子类未继承{0}中的私有readResolve方法。</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了一个私有readResolve方法。因为它是私有的，所以子类不会继承它。这可能是有意的，也可以，但应该进行审查，以确保它是有意的
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_READ_RESOLVE_MUST_RETURN_OBJECT">
    <ShortDescription>readResolve方法必须使用Object的返回类型声明。</ShortDescription>
<LongDescription>方法{1}必须使用Object的返回类型声明，而不是{1.returnType}</LongDescription>
    <Details>
<![CDATA[
  <p> 为了使序列化机制识别readResolve方法，必须将其声明为具有Object的返回类型
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS">
    <ShortDescription>不可序列化的类的瞬态字段。</ShortDescription>
<LongDescription>{1.givenClass}是临时的，但{0}不可序列化</LongDescription>
    <Details>
<![CDATA[
  <p> 字段被标记为瞬态，但类不是可序列化的，因此将其标记为瞬态绝对没有影响。
  这可能是以前版本的代码留下的标记，其中的类是暂时的，或者它可能表明对序列化工作方式的误解。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_TRANSIENT_FIELD_NOT_RESTORED">
    <ShortDescription>未通过反序列化设置的瞬态字段。</ShortDescription>
<LongDescription>字段{1}是临时的，但不是通过反序列化设置的</LongDescription>>
    <Details>
<![CDATA[
  <p> 这个类包含一个在类中多个位置更新的字段，因此它似乎是类状态的一部分。
  但是，由于该字段被标记为瞬态，并且未在readObject或readResolve中设置，因此它将在类的任何反序列化实例中包含默认值
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_METHOD_MUST_BE_PRIVATE">
   <ShortDescription>方法必须是私有的，序列化才能工作</ShortDescription>
<LongDescription>方法{1.givenClass}必须是私有的，才能在{0}的序列化反序列化中调用</LongDescription>
    <Details>
<![CDATA[
  <p> 此类实现<code>Serializable<code>接口，并定义自定义序列化反序列化的方法。但由于该方法未声明为private，因此它将被serializationdesialization API静默忽略.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION">
   <ShortDescription>类是Externalizable的，但没有定义void构造函数</ShortDescription>
<LongDescription>{0}是可Externalizable的，但未定义void构造函数</LongDescription>
    <Details>
<![CDATA[
  <p> 此类实现了<code>Externalizable<code>接口，但没有定义void构造函数。
  当对Externalizable对象进行反序列化时，首先需要通过调用void构造函数来构造它们。
  由于此类没有，序列化和反序列化将在运行时失败</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SUITABLE_CONSTRUCTOR">
    <ShortDescription>类是Serializable的，但它的超类没有定义void构造函数</ShortDescription>
<LongDescription>{0}是可序列化的，但其超类未定义可访问的void构造函数</LongDescription>
    <Details>
<![CDATA[
  <p> 此类实现<code>Serializable<code>接口，而其超类不实现。
  当这样的对象被反序列化时，需要通过调用超类的void构造函数来初始化超类的字段。
  由于超类没有，序列化和反序列化将在运行时失败</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NO_SERIALVERSIONID">
    <ShortDescription>类是Serializable的，但没有定义serialVersionUID</ShortDescription>
<LongDescription>{0}是可序列化的；请考虑声明SerialVersionUID</LongDescription>
    <Details>
<![CDATA[
  <p> 此类实现了<code>Serializable<code>接口，但没有定义<code>serialVersionUID<code>字段。
  像添加对.class对象的引用这样简单的更改将向该类添加合成字段，这将不幸地更改隐式的serialVersionUID(例如，添加对<code>String.class<code>的引用将生成静态字段<code>class$java$lang$string<code>)。
  此外，字节码编译器的不同源代码可能对为类对象或内部类的引用生成的合成变量使用不同的命名约定。
  为了确保Serializable跨版本的互操作性，请考虑添加显式的serialVersionUID.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_COMPARATOR_SHOULD_BE_SERIALIZABLE">
    <ShortDescription>比较器未实现序列化</ShortDescription>
<LongDescription>{0}实现了比较器，但不是可序列化的</LongDescription>
    <Details>
<![CDATA[
  <p> 此类实现<code>Comparator<code>接口。您应该考虑它是否还应该实现<code>Serializable<code>接口。
  如果使用比较器来构造有序集合(如<code>treemap<code>)，则只有当比较器也是可序列化的时，<code>treemap<code>才是可序列化的。
  由于大多数比较器只有很少的状态或没有状态，使它们可序列化通常是很容易的，也是很好的防御性编程
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_FALLTHROUGH">
   <ShortDescription>发现switch语句，其中一个case落入下一个case</ShortDescription>
<LongDescription>在{1}中找到switch语句，其中一个case落入下一个case</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法包含switch语句，其中一个case分支将落入下一个case。通常情况下，您需要以中断或返回来结束此情况.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_SWITCH_NO_DEFAULT">
    <ShortDescription>发现缺少缺省大小写的switch语句</ShortDescription>
<LongDescription>在{1}中找到switch语句，其中缺少默认大小写</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法包含缺少默认case的switch语句。通常需要提供默认大小写。</p>
  <p>因为分析仅查看生成的字节码，如果默认大小写位于switch语句的末尾，并且switch语句不包含其他大小写的break语句，则可能会错误触发此警告
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH">
   <ShortDescription>由于SWITCH语句FROUT而导致的死库</ShortDescription>
<LongDescription>由于switch语句落空，先前case中的{2.givenClass}的值在此处被覆盖</LongDescription>
    <Details>
<![CDATA[
  <p> 由于交换机故障，存储在前一个交换机案例中的值在此处被覆盖。很可能是您忘了在前一个案例的末尾放一个中断或回车。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW">
    <ShortDescription>由于switch语句落入抛出而导致死存储区</ShortDescription>
<LongDescription>
由于switch语句Fall through to抛出，前一个案例中的{2.givenClass}的值在此处丢失
</LongDescription>
    <Details>
<![CDATA[
  <p> 由于开关落入抛出异常的位置，因此此处忽略了上一个开关用例中存储的值。很可能是您忘了在前一个案例的末尾放一个中断或回车
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="WS_WRITEOBJECT_SYNC">
    <ShortDescription>类的writeObject()方法是同步的，但其他任何东西都不同步</ShortDescription>
<LongDescription>{0}的writeObject方法已同步，但其他任何内容都不同步</LongDescription>
    <Details>
<![CDATA[
  <p> 此类有一个同步的<code>writeObject()<code>方法；但是该类的其他方法没有同步.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RS_READOBJECT_SYNC">
   <ShortDescription>类的readObject()方法已同步</ShortDescription>
<LongDescription>{0}的readObject方法已同步</LongDescription>
    <Details>
<![CDATA[
  <p> 此可序列化类定义了一个同步的<code>readObject()<code>。
  根据定义，通过反序列化创建的对象只能由一个线程访问，因此不需要同步<code>readObject()<code>。
  如果<code>readObject()<code>方法本身导致该对象对另一个线程可见，则这是非常可疑的编码样式的示例。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONSTATIC_SERIALVERSIONID">
   <ShortDescription>serialVersionUID不是静态的</ShortDescription>
<LongDescription>{1}不是静态的</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了一个非静态的<code>serialVersionUID<code>字段。
  如果该字段旨在指定用于序列化目的版本UID，则应将该字段设置为静态.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONFINAL_SERIALVERSIONID">
    <ShortDescription>serialVersionUID不是最终的</ShortDescription>
<LongDescription>{1}不是最终版本</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了一个非final的<code>serialVersionUID<code>字段。
  如果该字段旨在指定用于序列化目的版本UID，则应将该字段设为final</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_NONLONG_SERIALVERSIONID">
    <ShortDescription>serialVersionUID不长</ShortDescription>
<LongDescription>{1}不长</LongDescription>
    <Details>
<![CDATA[
  <p> 此类定义了一个不长的<code>serialVersionUID<code>字段
  如果要指定用于序列化目的版本UID，则应将该字段设置为LONG</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD">
    <ShortDescription>可序列化类中的非瞬态不可序列化实例字段</ShortDescription>
<LongDescription>类{0}定义非瞬时不可序列化实例字段{1.name}</LongDescription>>
    <Details>
<![CDATA[
<p> 此Serializable类定义了一个非基元实例字段，该字段既不是瞬态的、Serializable的，也不是<code>java.lang.Object<code>，
并且似乎没有实现<code>Externalizable<code>接口或<code>readObject()和<code>writeObject()<code>方法。
如果在此中存储了非Serializable对象，则无法正确反序列化此类的对象</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_INNER_CLASS">
    <ShortDescription>不可序列化的类具有可序列化的内部类</ShortDescription>
<LongDescription>{0}是可序列化的，但也是不可序列化类的内部类</LongDescription>
    <Details>
<![CDATA[
<p> 此Serializable类是内部类。任何序列化它的尝试也将序列化关联的外部实例。外部实例是可序列化的，因此这不会失败，但它可能会序列化比预期多得多的数据。
</p>
<p>如果可能，使内部类成为静态内部类(也称为嵌套类)应该可以解决问题。
使外部类可序列化也可能有效，但这意味着序列化内部类的实例总是会序列化外部类的实例，这通常不是你真正想要的。
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_INNER_CLASS">
    <ShortDescription>可序列化的内部类</ShortDescription>
<LongDescription>{0}是可序列化的，并且是内部类</LongDescription>
    <Details>
<![CDATA[
<p> 此Serializable类是内部类。任何序列化它的尝试也将序列化关联的外部实例。外部实例是可序列化的，因此这不会失败，但它可能会序列化比预期多得多的数据。
如果可能，使内部类成为静态内部类(也称为嵌套类)应该可以解决问题。
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SE_BAD_FIELD_STORE">
    <ShortDescription>存储在可序列化类的实例字段中的不可序列化的值</ShortDescription>
<LongDescription>{2}存储在非临时字段{1.givenClass}中</LongDescription>
    <Details>
<![CDATA[
<p> 不可序列化的值存储在可序列化类的非瞬态字段中.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SC_START_IN_CTOR">
    <ShortDescription>构造函数调用Thread.start()</ShortDescription>
<LongDescription>{1}调用{2}</LongDescription>
    <Details>
<![CDATA[
  <p> 构造函数启动线程。如果类曾经扩展过subclassed，这很可能是错误的，因为线程将在子类构造函数启动之前启动</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SS_SHOULD_BE_STATIC">
    <ShortDescription>未读字段：这个字段应该是静态的吗？</ShortDescription>
<LongDescription>未读字段：{1}；此字段是否应为静态？</LongDescription>
    <Details>
<![CDATA[
  <p> 此类包含初始化为编译时静态值的实例final字段。考虑将字段设为静态</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_FIELD">
   <ShortDescription>未使用的字段</ShortDescription>
<LongDescription>未使用的字段：{1}</LongDescription>
    <Details>
<![CDATA[
  <p> 从不使用此字段 考虑将其从类中删除.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_FIELD">
    <ShortDescription>未读字段</ShortDescription>
<LongDescription>未读字段：{1}</LongDescription>
    <Details>
<![CDATA[
  <p> 从不读取此字段。考虑将其从类中删除</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未使用的公共或受保护字段</ShortDescription>
<LongDescription>未使用的公共或受保护字段：{1}</LongDescription>
    <Details>
<![CDATA[
  <p> 从未使用过此字段。&nbsp；此字段是公共的或受保护的，因此它可能用于未被视为分析一部分的类。
  如果没有，请考虑将其从类中删除</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未读公共保护字段</ShortDescription>
<LongDescription>未读的public protected字段：{1}</LongDescription>
    <Details>
<![CDATA[
  <p>此字段永远不会被读取。
  该字段是公共的或受保护的，因此它可能用于未被视为分析一部分的类。
  如果没有，请考虑将其从类中删除</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="QF_QUESTIONABLE_FOR_LOOP">
    <ShortDescription>for循环中复杂、微妙或错误的增量</ShortDescription>
<LongDescription>for循环{1}中的增量复杂、微妙或错误</LongDescription>
    <Details>
<![CDATA[
   <p>是否确定此for循环正在递增正确的变量？似乎另一个变量正在被for循环初始化和检查
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_NULL_FIELD">
    <ShortDescription>字段仅设置为NULL</ShortDescription>
<LongDescription>字段仅设置为NULL：{1}</LongDescription>
    <Details>
<![CDATA[
  <p> 对此字段的所有写入都是常量值NULL，因此对该字段的所有读取都将返回NULL。
  检查错误，如果它是无用的，则将其删除</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
    <ShortDescription>未写入的公共或受保护字段</ShortDescription>
<LongDescription>未写入的公共或受保护字段：{1}</LongDescription>
    <Details>
<![CDATA[
  <p> 未看到对此public protected字段的写入。&nbsp；对它的所有读取都将返回默认值。检查错误(应该已经初始化了吗？)，如果它是无用的，则将其删除.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_UNWRITTEN_FIELD">
    <ShortDescription>未写字段</ShortDescription>
<LongDescription>未写入的字段：{1}</LongDescription>
    <Details>
<![CDATA[
  <p> 此字段从不写入。
  对它的所有读取都将返回默认值。检查错误(应该已经初始化了吗？)，如果它是无用的，则将其删除。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD">
    <ShortDescription>从实例方法写入静态字段</ShortDescription>
<LongDescription>从实例方法{1}写入静态字段{2}</LongDescription>
    <Details>
<![CDATA[
  <p> 此实例方法写入静态字段。如果有多个实例被操纵，这是很难得到正确的，而且通常是不好的做法。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_LOAD_OF_KNOWN_NULL_VALUE">
   <ShortDescription>已知空值的加载</ShortDescription>
<LongDescription>{1}中已知空值的加载</LongDescription>
    <Details>
<![CDATA[
  <p> 由于早先对NULL进行了检查，此时引用的变量已知为NULL。
  虽然这是有效的，但它可能是一个错误(可能您打算引用不同的变量，或者可能之前检查该变量是否为NULL应该是检查它是否为非NULL)。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_DEREFERENCE_OF_READLINE_VALUE">
    <ShortDescription>取消引用readLine()的结果而不使用nullcheck</ShortDescription>
<LongDescription>取消引用{1}中不带nullcheck的readLine()的结果</LongDescription>
    <Details>
<![CDATA[
  <p> 调用readLine()的结果被取消引用，而不检查结果是否为NULL。如果没有更多的文本行要读取，readLine()将返回null并取消引用，这将生成null指针异常
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_IMMEDIATE_DEREFERENCE_OF_READLINE">
  <ShortDescription>立即取消引用readLine()的结果</ShortDescription>
<LongDescription>立即取消引用{1}中readLine()的结果</LongDescription>
    <Details>
<![CDATA[
  <p> 调用readLine()的结果立即被取消引用。如果没有更多的文本行要读取，readLine()将返回null并取消引用，这将生成null指针异常
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_FIELD">
    <ShortDescription>未写入字段的读取</ShortDescription>
<LongDescription>读取{1}中未写入的字段{2.name}</LongDescription>
    <Details>
<![CDATA[
  <p> 程序正在取消对似乎从未写入非空值的字段的引用。除非通过分析看不到的某种机制对字段进行初始化，否则取消引用此值将生成空指针异常
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD">
   <ShortDescription>读取未写入的公共或受保护字段</ShortDescription>
<LongDescription>读取{1}中未写入的公共或受保护字段{2.name}</LongDescription>
    <Details>
<![CDATA[
  <p> 程序正在取消对似乎从未写入非空值的公共或受保护字段的引用。除非通过分析看不到的某种机制对字段进行初始化，否则取消引用此值将生成空指针异常
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_THREADLOCAL_DEADLY_EMBRACE">
    <ShortDescription>致命地拥抱非静态内部类和线程本地</ShortDescription>
<LongDescription>{0}需要为_static_以避免与{1}发生致命拥抱</LongDescription>
    <Details>
<![CDATA[
  <p> 此类是内部类，但可能是静态内部类。实际上，内部类和外部类中的线程本地之间存在致命拥抱的严重危险。
  因为内部类不是静态的，所以它保留了对外部类的引用。
  如果线程本地包含对内部类的实例的引用，则内部和外部实例都是可访问的，并且不符合垃圾收集的条件
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC">
    <ShortDescription>应该是静态内部类</ShortDescription>
<LongDescription>{0}应该是_static_internal类吗？</LongDescription>
    <Details>
<![CDATA[
  <p> 此类是内部类，但不使用其对创建它的对象的嵌入引用。
  此引用使该类的实例更大，并可能使对创建者对象的引用比必要时更长。
  如果可能，应将该类设为静态
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR">
    <ShortDescription>字段未在构造函数中初始化，但在未进行NULL检查的情况下取消引用</ShortDescription>
<LongDescription>{1.givenClass}未在构造函数中初始化并在{2}中取消引用</LongDescription>
    <Details>
<![CDATA[
  <p> 此字段从不在任何构造函数中初始化，因此在构造对象后可能为NULL。在其他地方，它在没有空检查的情况下被加载和取消引用。
  这可能是一个错误或有问题的设计，因为这意味着如果该字段在初始化之前被取消引用，则将生成空指针异常
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_ANON">
    <ShortDescription>可以重构为命名的静态内部类</ShortDescription>
<LongDescription>类{0}可以重构为NAMED_STATIC_INTERNAL类</LongDescription>
    <Details>
<![CDATA[
  <p> 此类是内部类，但不使用其对创建它的对象的嵌入引用。
  此引用使该类的实例更大，并可能使对创建者对象的引用比所需的时间更长
  如果可能，应使该类成为<em>static<em>内部类。
  由于匿名内部类不能标记为静态，因此这样做将需要重构内部类，使其成为命名的内部类.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS">
    <ShortDescription>可以重构为静态内部类</ShortDescription>
<LongDescription>类{0}可以重构为_static_internal类</LongDescription>
    <Details>
<![CDATA[
  <p> 此类是内部类，但除非在内部对象的构造过程中，否则不使用其对创建它的对象的嵌入引用。
  此引用使该类的实例更大，并可能使对创建者对象的引用比所需的时间更长。
  如果可能，应使该类成为<em>static<em>内部类。
  由于内部实例的构造过程中需要对外部对象的引用，因此需要重构内部类，以便将对外部实例的引用传递给内部类的构造函数</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_NOT_IN_LOOP">
    <ShortDescription>等待不在循环中</ShortDescription>
<LongDescription>等待不在{1}中的循环中</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法包含对不在循环中的<code>java.lang.Object.wait()的调用。&nbsp；如果监视器用于多个条件，则调用者打算等待的条件可能不是实际发生的条件.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="WA_AWAIT_NOT_IN_LOOP">
    <ShortDescription>Condition.await()不在循环中</ShortDescription>
<LongDescription>Condition.await()不在{1}中的循环中</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法包含对不在循环中的<code>java.util.concurrent.await()(或变体)的调用。&nbsp；
  如果对象用于多个条件，则调用方打算等待的条件可能不是实际发生的条件.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NO_NOTIFY_NOT_NOTIFYALL">
   <ShortDescription>使用Notify()而不是NotifyAll()</ShortDescription>
<LongDescription>在{1}中使用Notify而不是NotifyAll</LongDescription>
    <Details>
<![CDATA[
  <p> 此方法调用<code>Notify()<code>而不是<code>NotifyAll()<code>。&nbsp；Java监视器通常用于多个条件。&nbsp；
  调用<code>Notify()<code>只唤醒一个线程，这意味着唤醒的线程可能不是等待调用者刚刚满足的条件的线程</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_VOID_METHOD">
   <ShortDescription>无用非空法</ShortDescription>
<LongDescription>方法{1}似乎无用</LongDescription>
    <Details>
<![CDATA[
<p>我们的分析表明，这个非空void方法实际上并没有执行任何有用的工作。请检查一下：它的代码可能有错误，或者它的身体可以完全移除。
</p>
<p>我们正在尝试尽可能减少误报，但在某些情况下，此警告可能是错误的。常见的假阳性情况包括:</p>
<p>- 该方法旨在触发某些可能会产生副作用的类的加载.</p>
<p>- 该方法旨在隐式抛出一些晦涩难懂的异常</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION">
    <ShortDescription>条件不起作用</ShortDescription>
<LongDescription>无用条件：此时已知{2}</LongDescription>
    <Details>
<![CDATA[
<p>此条件始终会产生与之前缩小相关变量值相同的结果。可能有其他意思或条件可以删除.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_CONDITION_TYPE">
    <ShortDescription>由于变量类型，条件没有影响</ShortDescription>
<LongDescription>无用条件：始终为{2}，因为变量类型为{3}</LongDescription>
    <Details>
<![CDATA[
<p>由于所涉及变量的类型范围，此条件始终会产生相同的结果。可能有其他意思或条件可以删除</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT">
    <ShortDescription>创建的无用对象</ShortDescription>
<LongDescription>无用对象存储在方法{1}的变量{2}中</LongDescription>
    <Details>
<![CDATA[
<p>我们的分析表明这个对象是无用的。它是被创建和修改的，但是它的值永远不会超出方法，也不会产生任何副作用。存在错误，并且对象是要使用的，或者可以将其删除。</p>
<p>分析很少产生误报。常见的假阳性情况包括：</p>
<p>-此对象用于隐式抛出某些晦涩的异常</p>
<p>- 此对象用作存根以泛化代码.</p>
<p>- 此对象用于保存对弱软引用对象的强引用</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UC_USELESS_OBJECT_STACK">
    <ShortDescription>堆栈上创建的无用对象</ShortDescription>
<LongDescription>方法{1}中创建的无用对象</LongDescription>
    <Details>
<![CDATA[
<p>创建此对象只是为了执行一些没有任何副作用的修改。可能有其他意思，或者可以删除该对象.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_INDEX">
    <ShortDescription>数组索引超出界限</ShortDescription>
<LongDescription>数组索引超出界限：{3}</LongDescription>
    <Details>
<![CDATA[
   <p>已执行数组操作，但数组索引超出界限，这将导致运行时出现ArrayIndexOutOfBorsException.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_OFFSET">
   <ShortDescription>数组偏移量超出界限</ShortDescription>
<LongDescription>数组偏移超出界限：{3}</LongDescription>
    <Details>
<![CDATA[
   <p> 使用数组参数和偏移量参数调用<p>方法，但偏移量超出界限。这将在运行时导致IndexOutOfBorsException</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_ARRAY_LENGTH">
    <ShortDescription>数组长度超出界限</ShortDescription>
<LongDescription>数组长度超出界限：{3}</LongDescription>
    <Details>
<![CDATA[
   <p> 使用数组参数和长度参数调用<p>方法，但长度超出界限。这将在运行时导致IndexOutOfBorsException. </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RANGE_STRING_INDEX">
   <ShortDescription>字符串索引超出界限</ShortDescription>
<LongDescription>调用{5}时字符串索引越界：{3}</LongDescription>>
    <Details>
<![CDATA[
   <p> 调用了字符串方法，指定的字符串索引超出界限。这将导致在运行时出现StringIndexOutOfBorsException</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_FOR_POSITIVE_INDEXOF">
    <ShortDescription>方法检查String.indexOf的结果是否为正</ShortDescription>
<LongDescription>{1}检查String.indexOf的结果是否为正</LongDescription>
    <Details>
<![CDATA[
   <p> 该方法调用String.indexOf并检查结果是正还是非正。
   更典型的是检查结果是否定的还是非否定的。仅当检查的子字符串出现在字符串开头以外的某个位置时，它才为正</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_DONT_JUST_NULL_CHECK_READLINE">
    <ShortDescription>方法在检查readLine是否非空后丢弃它的结果</ShortDescription>
<LongDescription>{1}在检查readLine是否非空后丢弃它的结果</LongDescription>
    <Details>
<![CDATA[
   <p> 检查readLine返回值是否为非空后，丢弃readLine返回值。
   在几乎所有情况下，如果结果为非空值，则需要使用该非空值。再次调用readLine将为您提供不同的线路</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_INFERRED">
    <ShortDescription>方法忽略返回值，这样可以吗？</ShortDescription>
<LongDescription>忽略了{2.givenClass}的返回值，这在{1}中是否正常</LongDescription>
    <Details>
<![CDATA[
<p>此代码调用方法并忽略返回值。返回值与调用方法的类型相同，从我们的分析来看，返回值可能很重要(例如，像忽略<code>String.toLowerCase()<code>的返回值)。
</p>
<p>我们猜测，仅从对方法体的简单分析中，忽略返回值可能是一个坏主意。您可以使用@CheckReturnValue注释来指示FindBugs忽略此方法的返回值是重要的还是可接受的。
</p>
<p>请仔细研究这一点，以决定是否可以忽略返回值
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT">
   <ShortDescription>忽略没有副作用的方法的返回值</ShortDescription>
<LongDescription>忽略了{2.givenClass}的返回值，但方法没有副作用</LongDescription>
    <Details>
<![CDATA[
<p>此代码调用方法并忽略返回值。然而，我们的分析表明该方法(如果有的话，包括它在子类中的实现)不会产生除了返回值以外的任何效果。因此，可以删除此调用。
</p>
<p>我们正在尝试尽可能减少误报，但在某些情况下，此警告可能是错误的。常见的假阳性情况包括:</p>
<p>- 该方法被设计为被覆盖，并在超出分析范围的其他项目中产生副作用。</p>
<p>- 调用该方法以触发可能具有副作用的类加载.</p>
<p>- 调用该方法只是为了获得一些异常.</p>
<p>如果您认为我们的假设不正确，可以使用@CheckReturnValue批注来指示FindBugs忽略.
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="RV_RETURN_VALUE_IGNORED">
    <ShortDescription>方法忽略返回值</ShortDescription>
<LongDescription>{1}中忽略{2.givenClass}的返回值</LongDescription>
    <Details>
<![CDATA[
   <p> 应检查此方法的返回值。此警告的一个常见原因是调用不可变对象上的方法，认为它会更新该对象。例如，在下面的代码片段中，</p>
<blockquote>
<pre>
String dateString = getHeaderField(name);
dateString.trim();
</pre>
</blockquote>
<p>程序员似乎认为trim()方法将更新dateString引用的字符串。但是由于String是不可变的，trim()函数返回一个新的字符串值，这里忽略了这个值。
应将代码更正为： </p>
<blockquote>
<pre>
String dateString = getHeaderField(name);
dateString = dateString.trim();
</pre>
</blockquote>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE">
    <ShortDescription>方法忽略异常返回值</ShortDescription>
<LongDescription>{1}中忽略了{2}的异常返回值</LongDescription>

    <Details>
<![CDATA[
   <p> 此方法返回未检查的值。应检查返回值，因为它可能指示异常或意外的函数执行。
   例如，如果无法成功删除文件(而不是抛出异常)，<code>File.delete()<code>方法将返回false。
   如果不检查结果，就不会注意到方法调用是否通过返回非典型返回值来发出意外行为的信号
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE">
    <ShortDescription>代码检查compareto返回的特定值</ShortDescription>
<LongDescription>检查{2.givenClass}的返回值是否等于{3}</LongDescription>>
    <Details>
<![CDATA[
   <p> 此代码调用compareto或Compare方法，并检查返回值是否为特定值，如1或-1。
   在调用这些方法时，应该只检查结果的符号，而不是任何特定的非零值。
   虽然许多或大多数compareto和Compare方法只返回-1、0或1，但其中一些方法将返回其他值。
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_EXCEPTION_NOT_THROWN">
   <ShortDescription>异常已创建并丢弃，而不是引发</ShortDescription>
<LongDescription>{2.givenClass}未抛入{1}</LongDescription>
    <Details>
<![CDATA[
   <p> 此代码创建一个异常（或错误）对象，但不对其执行任何操作。 例如，像 </p>
<blockquote>
<pre>
if (x &lt; 0)
  new IllegalArgumentException("x must be nonnegative");
</pre>
</blockquote>
<p>It was probably the intent of the programmer to throw the created exception:</p>
<blockquote>
<pre>
if (x &lt; 0)
  throw new IllegalArgumentException("x must be nonnegative");
</pre>
</blockquote>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL">
    <ShortDescription>空指针取消引用</ShortDescription>
<LongDescription>{1}中{2.givenClass}的指针取消引用为空</LongDescription>
    <Details>
<![CDATA[
<p> 此处取消引用NULL指针。&nbsp；这将导致在执行代码时出现<code>NullPointerException<code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_CLOSING_NULL">
    <ShortDescription>在始终为NULL的值上调用close()</ShortDescription>
<LongDescription>无法关闭{2.givenClass}，因为它在{1}中始终为NULL</LongDescription>
    <Details>
<![CDATA[
<p> 正在对始终为NULL的值调用<p>close()。如果执行此语句，将发生空指针异常。但这里最大的风险是你永远不会关闭应该关闭的东西
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_STORE_INTO_NONNULL_FIELD">
   <ShortDescription>将空值存储到标注为@Nonnull的字段中</ShortDescription>
<LongDescription>将空值存储到{1}中注释为@Nonnull的字段{2.givenClass}中</LongDescription>
    <Details>
      <![CDATA[
<p> 可能为NULL的值存储在已注释为@Nonnull的字段中 </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_ALWAYS_NULL_EXCEPTION">
    <ShortDescription>异常路径上的方法中的空指针取消引用</ShortDescription>
<LongDescription>在异常路径上{1}中{2.givenClass}的指针取消引用为空</LongDescription>>
    <Details>
<![CDATA[
<p> 此处取消引用异常路径上为NULL的指针。&nbsp；这将导致在执行代码时出现<code>NullPointerException<code>。&nbsp；请注意，由于FindBugs当前不会修剪不可行的异常路径，因此这可能是错误警告。.</p>

<p> 还请注意，FindBugs将switch语句的默认情况视为异常路径，因为默认情况通常是不可行的</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE">
   <ShortDescription>参数必须为非null，但标记为可为null</ShortDescription>
<LongDescription>{2}必须为非null，但标记为可为null</LongDescription>
    <Details>
<![CDATA[
<p>此参数的使用方式始终要求其为非null，但该参数被显式注释为可为Nullable。参数的使用或注释都是错误的
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH">
    <ShortDescription>可能的空指针取消引用</ShortDescription>
<LongDescription>{1}中{2.givenClass}的可能NULL指针取消引用</LongDescription>
    <Details>
<![CDATA[
<p> 有一个语句分支，<em>如果执行，<em>保证NULL值将被取消引用，这将在代码执行时生成<code>NullPointerException<code>。
当然，问题可能是分支或语句是不可行的，并且空指针异常永远不能执行；决定这一点超出了FindBugs的能力
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE">
    <ShortDescription>分支上可能的空指针取消引用可能是不可行的</ShortDescription>
<LongDescription>分支上{2.givenClass}的可能的空指针取消引用在{1}中可能是不可行的</LongDescription>>
    <Details>
<![CDATA[
<p> 有一个语句分支，<em>如果执行，<em>保证NULL值将被取消引用，这将在代码执行时生成<code>NullPointerException<code>。
当然，问题可能是分支或语句是不可行的，并且空指针异常永远不能执行；决定这一点超出了FindBugs的能力。
由于此值之前已测试为空，因此这是一种确定的可能性
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_EXCEPTION">
   <ShortDescription>异常路径上的方法中可能存在空指针取消引用</ShortDescription>
<LongDescription>异常路径上{1}中{2.givenClass}的可能NULL指针取消引用</LongDescription>
>
    <Details>
<![CDATA[
<p> 此处取消引用某些异常控制路径上为NULL的引用值
这可能会导致在执行代码时出现<code>NullPointerException<code>。
请注意，由于FindBugs当前不会修剪不可行的异常路径，因此这可能是错误警告。
还请注意，FindBugs将switch语句的默认情况视为异常路径，因为默认情况通常是不可行的</p>

<p> Also note that FindBugs considers the default case of a switch statement to
be an exception path, since the default case is often infeasible.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE">
    <ShortDescription>由于被调用方法的返回值可能是空指针取消引用</ShortDescription>
<LongDescription>由于调用的方法的返回值，{1}中可能存在空指针取消引用</LongDescription>
    <Details>
      <![CDATA[
<p> 方法的返回值在没有NULL检查的情况下被取消引用，并且该方法的返回值通常应该检查为NULL。这可能导致在执行代码时出现<code>NullPointerException<code>
</p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_NONVIRTUAL">
    <ShortDescription>非虚方法调用为非空参数传递NULL</ShortDescription>
<LongDescription>{1}中的非虚方法调用为{2.givenClass}的非空参数传递NULL</LongDescription>
    <Details>
      <![CDATA[
      <p>
      将可能为NULL的值传递给非NULL方法参数。要么将参数注释为应该始终为非NULL的参数，要么分析表明它将始终被取消引用
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS">
    <ShortDescription>方法调用为非NULL参数传递NULL</ShortDescription>
<LongDescription>为{1}中{2.givenClass}的非空参数传递了NULL</LongDescription>
    <Details>
      <![CDATA[
      <p>
      在所有已知目标方法都要求参数非NULL的调用位置传递可能为NULL的值。
      要么将参数注释为应该始终为非NULL的参数，要么分析表明它将始终被取消引用
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_PARAM_DEREF">
   <ShortDescription>方法调用为非NULL参数传递NULL</ShortDescription>
<LongDescription>为{1}中{2.givenClass}的非空参数传递了NULL</LongDescription>
    <Details>
      <![CDATA[
      <p>
     此方法调用为非null方法参数传递null值。要么将参数注释为应该始终为非NULL的参数，要么分析表明它将始终被取消引用
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_PARAM_VIOLATION">
    <ShortDescription>方法调用将null传递给非null参数</ShortDescription>
<LongDescription>为{1}中{2.givenClass}的非空参数传递了NULL</LongDescription>
    <Details>
      <![CDATA[
      <p>
      此方法将NULL值作为方法的参数传递，该参数必须为非NULL。此参数已显式标记为@Nonnull，或者分析确定此参数始终被取消引用
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_NONNULL_RETURN_VIOLATION">
    <ShortDescription>克隆方法可能返回NULL</ShortDescription>
<LongDescription>{1}可能返回NULL</LongDescription>
    <Details>
      <![CDATA[
      <p>
      此clone方法在某些情况下似乎返回NULL，但决不允许clone返回NULL值。如果您确信此路径不可达，则抛出AssertionError
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_CLONE_COULD_RETURN_NULL">
    <ShortDescription>toString方法可能返回NULL</ShortDescription>
<LongDescription>{1}可能返回NULL</LongDescription>
    <Details>
      <![CDATA[
      <p>
此clone方法在某些情况下似乎返回NULL，但决不允许clone返回NULL值。如果您确信此路径不可达，则抛出AssertionError
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_TOSTRING_COULD_RETURN_NULL">
    <ShortDescription>toString方法可能返回NULL</ShortDescription>
<LongDescription>{1}可能返回NULL</LongDescription>
    <Details>
      <![CDATA[
      <p>
    此toString方法在某些情况下似乎返回NULL。对规范的自由阅读可以被解释为允许这样做，但这可能是一个坏主意，可能会导致其他代码崩溃。返回空字符串或其他适当的字符串，而不是NULL。
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF">
   <ShortDescription>保证取消对空值的引用</ShortDescription>
<LongDescription>{2.givenClass}可以为null，并保证在{1}中取消引用</LongDescription>
    <Details>
          <![CDATA[
              <p>
              存在一条语句或分支，如果执行该语句或分支，则保证此时值为NULL，并且该值保证被取消引用(涉及运行时异常的前向路径除外)。
              </p>
        <p>请注意，诸如<code>if(x=null)抛出新的NullPointerException()；
        <code>之类的检查被视为对<code>x<code>的取消引用</p>
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH">
    <ShortDescription>值为NULL，保证在异常路径上取消引用</ShortDescription>
<LongDescription>{2.name}为NULL，保证在异常路径的{1}中取消引用</LongDescription>
    <Details>
          <![CDATA[
              <p>
              异常路径上有一条语句或分支，如果执行该语句或分支，则保证此点的值为NULL，并且该值保证被取消引用(涉及运行时异常的前向路径除外)
              </p>
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="SI_INSTANCE_BEFORE_FINALS_ASSIGNED">
    <ShortDescription>静态初始值设定项在分配所有静态最终字段之前创建实例</ShortDescription>
<LongDescription>{0}的静态初始值设定项在分配所有静态最终字段之前创建实例</LongDescription>
    <Details>
<![CDATA[
<p> 类的静态初始值设定项在分配所有静态final字段之前创建类的实例</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM">
    <ShortDescription>方法可能无法关闭流</ShortDescription>
<LongDescription>{1}可能无法关闭流</LongDescription>
    <Details>
<![CDATA[
<p> 该方法创建一个IO流对象，不将其分配给任何字段，将其传递给其他可能关闭或返回该对象的方法，并且似乎没有关闭该方法的所有路径上的流。&nbsp；
这可能会导致文件描述符泄漏。&nbsp；
通常情况下，最好使用<code>final<code>块来确保流已关闭</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="OS_OPEN_STREAM_EXCEPTION_PATH">
    <ShortDescription>方法可能无法在发生异常时关闭流</ShortDescription>
<LongDescription>发生异常时{1}可能无法关闭流</LongDescription>
    <Details>
<![CDATA[
<p> 该方法创建一个IO流对象，不将其分配给任何字段，不将其传递给其他方法或返回它，并且似乎不会在方法之外的所有可能的异常路径上关闭它。&nbsp；这可能会导致文件描述符泄漏。&nbsp；通常情况下，最好使用<code>final<code>块来确保流是关闭的.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZLA_PREFER_ZERO_LENGTH_ARRAYS">
    <ShortDescription>考虑返回零长度数组而不是NULL</ShortDescription>
<LongDescription>{1}是否应该返回零长度数组而不是NULL？</LongDescription>
    <Details>
<![CDATA[
<p> 返回长度为零的数组而不是空引用通常是更好的设计，以指示没有结果（即，结果的空列表）。
这样，该方法的客户端不需要显式检查null。</p>

<p>另一方面，使用null表示“对这个问题没有答案”可能是合适的。
例如，如果给定一个不包含文件的目录，<code> File.listFiles（）</ code>返回一个空列表，如果该文件不是目录，则返回null.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW">
    <ShortDescription>无用控制流</ShortDescription>
<LongDescription>{1}中的无用控制流</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含一个无用的控制流语句，其中控制流继续到相同的位置，而不管是否采取分支。例如，这是由于<code>if<code>语句的空语句块：</p>
<pre>
    if (argv.length == 0) {
    // TODO: handle this case
    }
</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UCF_USELESS_CONTROL_FLOW_NEXT_LINE">
    <ShortDescription>无用的控制流到下一行</ShortDescription>
<LongDescription>无效的控制流到{1}中的下一行</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含无用的控制流程语句，其中无论是否采用分支，控制流都遵循相同或后续行。
通常，这是由于无意中使用空语句作为<code> if </ code>语句的主体引起的，例如:</p>
<pre>
    if (argv.length == 1);
        System.out.println("Hello, " + argv[0]);
</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE">
    <ShortDescription>以前取消引用的值的空检查</ShortDescription>
<LongDescription>{2.givenClass}在{4.lineNumber}处对之前在{1}中取消引用的值进行空检查</LongDescription>
    <Details>
<![CDATA[
<p> 此处检查一个值以查看它是否为null，但此值不能为null，因为它先前已取消引用，如果它为null，则在较早的取消引用时将发生空指针异常。
本质上，此代码和先前的取消引用不同意该值是否允许为空。 检查是多余的，或者先前的取消引用是错误的。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE">
    <ShortDescription>已知为空的值的冗余空检查</ShortDescription>
<LongDescription>{2}的冗余空检查，在{1}中已知为空</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含针对常量NULL的已知NULL值的冗余检查。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE">
    <ShortDescription>已知非空的值的冗余空检查</ShortDescription>
<LongDescription>{2}的冗余空检查，在{1}中已知为非空</LongDescription>
    <Details>
<![CDATA[
<p>此方法包含针对常量NULL的已知非NULL值的冗余检查</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES">
   <ShortDescription>两个空值的冗余比较</ShortDescription>
<LongDescription>{1}中两个空值的冗余比较</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含两个已知引用的冗余比较，这两个引用都肯定为null</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE">
   <ShortDescription>非空值与空值的冗余比较</ShortDescription>
<LongDescription>{1}中非NULL值与NULL的冗余比较</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含一个已知为非null的引用，而另一个已知为null的引用.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RCN_REDUNDANT_CHECKED_NULL_COMPARISON" deprecated="true">
    <!--不推荐使用两种不同的RCN_模式 -->
    <ShortDescription>与先前检查的值的NULL进行冗余比较</ShortDescription>
<LongDescription>与以前在{1}中检查的{2}的NULL进行冗余比较</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含引用值与NULL的冗余比较。报告了两种类型的冗余比较：
</p>
<ul>
<li> 两个比较的值都肯定是NULL</li>
<li> 一个值肯定是null而另一个绝对不是null</li>
</ul>

<p> 这个特定警告通常表示已知不是null的值被对照null进行了检查。虽然检查不是必需的，但它可能只是防御性编程的一种情况</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK">
   <ShortDescription>方法不会释放所有路径上的锁</ShortDescription>
<LongDescription>{1}不会释放所有路径上的锁定</LongDescription>
    <Details>
<![CDATA[
<p> 此方法获取JSR-166(<code>java.util.current<code>)锁，但不会在该方法的所有路径上释放它。通常，使用JSR-166锁的正确习惯用法是：
</p>
<pre>
    Lock l = ...;
    l.lock();
    try {
        // do something
    } finally {
        l.unlock();
    }
</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="UL_UNRELEASED_LOCK_EXCEPTION_PATH">
    <ShortDescription>方法不会释放所有异常路径上的锁</ShortDescription>
<LongDescription>{1}不会释放所有异常路径上的锁定</LongDescription>
    <Details>
<![CDATA[
<p> 此方法获取JSR-166(<code>java.util.current<code>)锁，但不会在方法外部的所有异常路径上释放它。通常，使用JSR-166锁的正确习惯用法是：
</p>
<pre>
    Lock l = ...;
    l.lock();
    try {
        // do something
    } finally {
        l.unlock();
    }
</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON">
    <ShortDescription>可疑参考比较</ShortDescription>
<LongDescription>{1}中{2}引用的可疑比较</LongDescription>
    <Details>
<![CDATA[
<p> 此方法使用=或！=运算符比较两个参考值，其中比较此类型实例的正确方法通常是使用equals()方法。
可以创建相同但不比较为=的不同实例，因为它们是不同的对象。
通常不应通过引用进行比较的类的示例有java.lang.Integer、java.lang.Float等</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE">
    <ShortDescription>对常量的可疑引用比较</ShortDescription>
<LongDescription>{2}对{1}中的常量的引用比较可疑</LongDescription>
    <Details>
<![CDATA[
<p> 此方法使用=或！=运算符将参考值与常量进行比较，其中比较此类型实例的正确方法通常是使用equals()方法。
可以创建相同但不比较为=的不同实例，因为它们是不同的对象。
通常不应通过引用进行比较的类的示例有java.lang.Integer、java.lang.Float等。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN">
    <ShortDescription>布尔值的可疑引用比较</ShortDescription>
<LongDescription>{1}中布尔引用的可疑比较</LongDescription>
    <Details>
<![CDATA[
<p> 此方法使用=或！=运算符比较两个布尔值。通常只有两个布尔值(Boolean.TRUE和Boolean.FALSE)，但是可以使用<code>new Boolean(B)<code>构造函数创建其他Boolean对象。
最好避免这样的对象，但如果它们确实存在，则使用=或！=检查布尔对象的相等性将得到与使用<code>.equals(.)<code><p>不同的结果
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES_USING_POINTER_EQUALITY">
    <ShortDescription>使用指针相等比较不同的类型</ShortDescription>
<LongDescription>使用指针相等将{2.givenClass}与{1}中的{3.givenClass}进行比较</LongDescription>
    <Details>
<![CDATA[
<p> 此方法使用指针相等来比较似乎是不同类型的两个引用。此比较的结果在运行时始终为false
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_TYPES">
    <ShortDescription>调用equals()比较不同类型</ShortDescription>
<LongDescription>在{1}中调用{3.simpleClass}.equals({2.simpleClass})</LongDescription>
    <Details>
<![CDATA[
<p> 此方法对两个不同类型的引用调用equals(对象)，分析表明它们将在运行时指向不同类的对象。
此外，对将要调用的equals方法的检查表明，要么这个调用总是返回false，要么equals方法不是对称的(这是类Object中的equals的约定所要求的属性)
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_INTERFACES">
    <ShortDescription>调用equals()比较不同的接口类型</ShortDescription>
<LongDescription>在{1}中调用{3.simpleClass}.equals({2.simpleClass})</LongDescription>
    <Details>
<![CDATA[
<p> 此方法在不相关接口类型的两个引用上调用equals(对象)，其中任何一个都不是另一个的子类型，并且没有已知的实现这两个接口的非抽象类。
因此，被比较的对象在运行时不太可能是同一个类的成员(除非一些应用程序类没有被分析，或者动态类加载可以在运行时发生)。
根据equals()的约定，不同类的对象应该始终比较为不相等；
因此，根据java.lang.Object.equals(Object)定义的约定，此比较的结果在运行时始终为false
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_UNRELATED_CLASS_AND_INTERFACE">
    <ShortDescription>调用equals()比较不相关的类和接口</ShortDescription>
<LongDescription>在{1}中调用{3.simpleClass}.equals({2.simpleClass})</LongDescription>
    <Details>
      <![CDATA[
<p>
此方法对两个引用调用equals(Object)，其中一个是类，另一个是接口，其中类及其任何非抽象子类都不实现接口。
因此，被比较的对象在运行时不太可能是同一个类的成员(除非一些应用程序类没有被分析，或者动态类加载可以在运行时发生)。
根据equals()的约定，不同类的对象应该始终比较为不相等；
因此，根据java.lang.Object.equals(Object)定义的约定，此比较的结果在运行时始终为false。
</p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="EC_NULL_ARG">
    <ShortDescription>调用等于(NULL)</ShortDescription>
<LongDescription>调用{1}中的Equals(NULL)</LongDescription>
    <Details>
<![CDATA[
<p> 此方法调用equals(Object)，传递空值作为参数。根据equals()方法的约定，此调用应始终返回<code>false<code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_WAIT">
    <ShortDescription>不匹配的wait()</ShortDescription>
<LongDescription>{1}中不匹配的wait()</LongDescription>
    <Details>
<![CDATA[
<p> 此方法调用Object.wait()时没有明显持有对象上的锁。&nbsp；在未持有锁的情况下调用wait()将导致引发<code>IllegalMonitorStateException<code></p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MWN_MISMATCHED_NOTIFY">
    <ShortDescription>不匹配的通知()</ShortDescription>
<LongDescription>{1}中的Notify()不匹配</LongDescription>
    <Details>
<![CDATA[
<p> 此方法调用Object.Notify()或Object.NotifyAll()而没有明显持有对象上的锁。&nbsp；调用Notify()或NotifyAll()而不持有锁将导致引发<code>IllegalMonitorStateException<code>.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD">
    <ShortDescription>本地的自赋值，而不是字段的赋值</ShortDescription>
<LongDescription>{2}的自分配，而不是分配给{1}中的字段</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含局部变量的自我赋值，并且存在具有相同名称的字段。赋值似乎是；例如 e.g.</p>
<pre>
  int foo;
  public void setFoo(int foo) {
    foo = foo;
  }
</pre>
<p>赋值无效。您的意思是改为分配给字段吗</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_ASSIGNMENT">
    <ShortDescription>局部变量自赋值</ShortDescription>
<LongDescription>{1}中{2}的自我分配</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含局部变量的自我赋值；例如.</p>
<pre>
  public void foo() {
    int x = 3;
    x = x;
  }
</pre>
<p>
这样的赋值是无用的，可能指示逻辑错误或打字错误。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_ASSIGNMENT">
    <ShortDescription>字段自分配</ShortDescription>
<LongDescription>{1}中字段{2.givenClass}的自赋值</LongDescription>
    <Details>
<![CDATA[
<p> 该方法包含字段的自我分配; e.g.
</p>
<pre>
  int x;
  public void foo() {
    x = x;
  }
</pre>
<p>这样的赋值是无用的，可能指示逻辑错误或打字错误.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_DOUBLE_ASSIGNMENT">
    <ShortDescription>字段的双重赋值</ShortDescription>
<LongDescription>{1}中字段{2.givenClass}的双重赋值</LongDescription>>
    <Details>
<![CDATA[
<p>此方法包含字段的双重赋值；例如，
</p>
<pre>
  int x,y;
  public void foo() {
    x = x = 17;
  }
</pre>
<p>对字段赋值两次是无用的，可能指示逻辑错误或打字错误.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_DOUBLE_ASSIGNMENT">
    <ShortDescription>局部变量的双重赋值</ShortDescription>
<LongDescription>{1}中{2}的双重赋值</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含局部变量的双重赋值；例如，
</p>
<pre>
  public void foo() {
    int x,y;
    x = x = 17;
  }
</pre>
<p>将相同的值两次赋值给变量是无用的，可能指示逻辑错误或打字错误。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPUTATION">
   <ShortDescription>涉及场的无意义的自我计算(例如，x x)</ShortDescription>
<LongDescription>{2.givenClass}的自身在{1}中的无意义的自我计算</LongDescription>
    <Details>
<![CDATA[
<p> 此方法使用对同一字段的另一个引用(例如，x&x或x-x)对字段执行无意义的计算。
由于计算的性质，这个操作似乎没有意义，并且可能表明输入错误或逻辑错误。仔细检查计算。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPUTATION">
    <ShortDescription>涉及变量的无意义的自我计算 (e.g., x &amp; x)</ShortDescription>
   <LongDescription>自身在{1}中的{2}的无意义的自我计算</LongDescription>
    <Details>
<![CDATA[
<p> 此方法使用对同一变量的另一个引用(例如，x&x或x-x)对局部变量执行无意义的计算。由于计算的性质，这个操作似乎没有意义，并且可能表明输入错误或逻辑错误。仔细检查计算。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_FIELD_SELF_COMPARISON">
    <ShortDescription>场与自身的自我比较</ShortDescription>
<LongDescription>{2.givenClass}与{1}中的自身进行自我比较</LongDescription>
    <Details>
<![CDATA[
<p> 此方法将字段与其自身进行比较，并可能指示键入错误或逻辑错误。确保你在比较正确的东西
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SA_LOCAL_SELF_COMPARISON">
    <ShortDescription>价值与自身的自我比较</ShortDescription>
<LongDescription>{2}与自身{1}的自我比较</LongDescription>
    <Details>
<![CDATA[
<p> 此方法将局部变量与其自身进行比较，并可能指示键入错误或逻辑错误。确保你在比较正确的东西。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT">
    <ShortDescription>对int调用的Double.longBitsToDouble</ShortDescription>
<LongDescription>在{1}中的int上调用了Double.longBitsToDouble</LongDescription>
    <Details>
<![CDATA[
<p> 调用Double.longBitsToDouble方法，但将32位int值作为参数传递。这几乎肯定不是有意的，也不太可能产生预期的结果。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ARGUMENTS_WRONG_ORDER">
    <ShortDescription>反向方法参数</ShortDescription>
<LongDescription>在{1}中调用{2.name}的参数顺序错误</LongDescription>
    <Details>
<![CDATA[
<p> 此方法调用的参数似乎是错误的顺序。
例如，调用<code> Preconditions.checkNotNull（“message”，message）</ code>具有保留参数：要检查的值是第一个参数。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_RANDOM_USED_ONLY_ONCE">
    <ShortDescription>随机对象只创建和使用一次</ShortDescription>
<LongDescription>随机对象在{1}中仅创建和使用一次</LongDescription>
    <Details>
<![CDATA[
<p>此代码创建一个java.util.Random对象，使用它生成一个随机数，然后丢弃Random对象。这会产生质量平庸的随机数，并且效率低下。
如果可能，重写代码，使Random对象只创建一次并保存，每次需要新的随机数时，调用现有Random对象上的方法来获取它。
</p>

<p>如果生成的随机数不可猜测这一点很重要，则您必须<em>不能为每个随机数创建新的随机数；
这些值太容易猜测。您应该强烈考虑使用java.security.SecureRandom(避免为每个所需的随机数分配新的SecureRandom)
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_RANDOM_INT">
    <ShortDescription>尝试计算有符号随机整数的绝对值时出错</ShortDescription>
<LongDescription>尝试计算{1}中有符号随机整数的绝对值时出错</LongDescription>
    <Details>
<![CDATA[
<p> 此代码生成一个随机有符号整数，然后计算该随机整数的绝对值。
如果随机数生成器返回的数字为<code>Integer.MIN_VALUE<code>，则结果也将为负(因为<code>Math.abs(Integer.MIN_Value)=Integer.MIN_Value<code>)。(长值也出现了同样的问题)
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_ABSOLUTE_VALUE_OF_HASHCODE">
    <ShortDescription>尝试计算有符号32位哈希码的绝对值时出错</ShortDescription>
<LongDescription>尝试计算{1}中有符号32位哈希码的绝对值时出错</LongDescription>
    <Details>
<![CDATA[
<p> 此代码生成哈希码，然后计算该哈希码的绝对值。
 如果哈希码是<code> Integer.MIN_VALUE </ code>，那么结果也将是否定的（因为<code> Math.abs（Integer.MIN_VALUE）== Integer.MIN_VALUE </ code>）。
</p>
<p>2 ^ 32个字符串中的一个具有Integer.MIN_VALUE的hashCode，包括“polygenelubricants”“GydZG_”和“”DESIGNING WORKHOUSES“。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_RANDOM_INT">
    <ShortDescription>32位有符号随机整数的余数</ShortDescription>
<LongDescription>在{1}中计算的32位有符号随机整数的余数</LongDescription>
    <Details>
<![CDATA[
<p> 此代码生成一个随机有符号整数，然后以另一个值为模计算该值的余数。
由于随机数可以是负数，所以余数运算的结果也可以是负数。
确保这是有意的，并强烈考虑改用Random.nextInt(Int)方法
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RV_REM_OF_HASHCODE">
    <ShortDescription>hashCode的剩余部分可以是负数</ShortDescription>
<LongDescription>hashCode的剩余部分在{1}中可以为负数</LongDescription>
    <Details>
<![CDATA[
<p> 此代码计算一个hashCode，然后以另一个值为模计算该值的余数。由于hashCode可以是负数，所以余数运算的结果也可以是负数。 </p>
<p> 假设您希望确保计算结果为非负数，则可能需要更改代码。
如果知道除数是2的幂，则可以使用按位AND运算符(即，不使用<code>x.hashCode()%n<code>，而使用<code>x.hashCode()&amp；(n-1)<code>)。这可能比计算余数更快。如果不知道除数是2的幂，则取余数运算结果的绝对值(即使用<code>Math.abs(x.hashCode()%n)
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE">
   <ShortDescription>非负值与负常量或零的错误比较</ShortDescription>
<LongDescription>非负值与{1}中的{2}的比较不正确</LongDescription>
    <Details>
<![CDATA[
<p> 此代码将保证为非负值的值与负常量或零进行比较
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="INT_BAD_COMPARISON_WITH_SIGNED_BYTE">
    <ShortDescription>有符号字节的错误比较</ShortDescription>
<LongDescription>{1}中有符号字节与{2}的比较不正确</LongDescription>>
    <Details>
<![CDATA[
<p> 有符号字节只能具有-128到127之间的值。
将有符号字节与该范围之外的值进行比较是空洞的，并且很可能是不正确的。若要将有符号字节<code>b<code>转换为0..255范围内的无符号值，请使用<code>0xff&amp；b<code>
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_COMPARISON_WITH_INT_VALUE">
    <ShortDescription>INT值与长常数的比较不正确</ShortDescription>
<LongDescription>int与{1}中的{2}的比较不正确</LongDescription>
    <Details>
<![CDATA[
<p>此代码将int值与超出可以表示为int值的值范围的长常量进行比较。这种比较是空洞的，很可能是不正确的
</p>
]]>
    </Details>
  </BugPattern>


  <BugPattern type="INT_VACUOUS_BIT_OPERATION">
    <ShortDescription>整数值上的空位掩码操作</ShortDescription>
<LongDescription>{1}中{3}上的空{2}操作</LongDescription>
    <Details>
<![CDATA[
<p> 这是一个整数位运算(AND、OR或EXCLUSIVE OR)，不做任何有用的工作(例如，<code>v&0xffffffff<code>)

</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_VACUOUS_COMPARISON">
    <ShortDescription>整数值的空比较</ShortDescription>
<LongDescription>整数值{1}的空比较</LongDescription>
    <Details>
<![CDATA[
<p> 存在始终返回相同值的整数比较(例如，x&lt；=Integer.MAX_VALUE)
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="INT_BAD_REM_BY_1">
    <ShortDescription>整数余数模1</ShortDescription>
<LongDescription>{1}中计算的整数余数模1</LongDescription>
    <Details>
<![CDATA[
<p>任何表达式(exp%1)都保证始终返回零。您是指(exp&amp；1)还是(exp%2)？
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR_OF_SIGNED_BYTE">
    <ShortDescription>Bitwise OR of signed byte value</ShortDescription>
    <LongDescription>Bitwise OR of signed byte value computed in {1} </LongDescription>
    <Details>
<![CDATA[
<p> 加载字节值(例如，从字节数组加载的值或返回类型为byte的方法返回的值)，并对该值执行逐位OR。
在对该值执行任何按位运算之前，字节值被符号扩展到32位。因此，如果<code>b[0]<code>包含值<code>0xff<code>，并且x最初为0，则code<code>(x&lt；&lt；8)|b[0])<code>将签名EXTEND<code>0xff<code>以获取0xffffffff，并因此给出值0xffffffff作为结果。
</p>

<p>特别是下面用于将字节数组打包到int中的代码是严重错误的：</p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++)
  result = ((result &lt;&lt; 8) | b[i]);
</pre>

<p>The following idiom will work instead: </p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++)
  result = ((result &lt;&lt; 8) | (b[i] &amp; 0xff));
</pre>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_ADD_OF_SIGNED_BYTE">
    <ShortDescription>有符号字节值的逐位相加</ShortDescription>
<LongDescription>{1}中计算的有符号字节值的逐位相加</LongDescription>
    <Details>
<![CDATA[
<p> 添加一个字节值和一个已知已清除8个低位的值。
从字节数组加载的值在对该值执行任何按位操作之前，将被符号扩展为32位。
因此，如果<code>b[0]<code>包含值<code>0xff<code>，并且x最初为0，则code<code>(x&lt；&lt；8)+b[0])<code>将符号Extend 0xff<code>以获得0xffffffff，并因此给出值0xffffffff作为结果。
</p>

<p>特别是下面用于将字节数组打包到int中的代码是严重错误的： </p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++)
  result = ((result &lt;&lt; 8) + b[i]);
</pre>

<p>The following idiom will work instead: </p>
<pre>
int result = 0;
for(int i = 0; i &lt; 4; i++)
  result = ((result &lt;&lt; 8) + (b[i] &amp; 0xff));
</pre>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND">
   <ShortDescription>不兼容的位掩码</ShortDescription>
<LongDescription>(e{2}={3})中不兼容的位掩码产生{1}中的常量结果</LongDescription>
    <Details>
<![CDATA[
<p> 此方法将(e&amp；C)形式的表达式与D进行比较，由于常数C和D的特定值，D总是比较不相等。这可能表示逻辑错误或打字错误.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK">
    <ShortDescription>检查按位运算的符号</ShortDescription>
<LongDescription>检查{1}中位运算的符号</LongDescription>
    <Details>
<![CDATA[
<p> 此方法比较一个表达式，例如</p>
<pre>((event.detail &amp; SWT.SELECTED) &gt; 0)</pre>.
<p>使用位算术，然后与大于运算符进行比较可能会导致意外的结果(当然取决于SWT.SELECTED的值)。如果SWT.SELECTED是负数，则这是bug的候选。
即使SWT.SELECTED不是负的，使用‘！=0’而不是‘&gt；0’似乎也是一种很好的做法。
</p>
<p>
<em>Boris Bokowski</em>
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_SIGNED_CHECK_HIGH_BIT">
    <ShortDescription>检查按位运算的符号</ShortDescription>
<LongDescription>检查{1}中位运算的符号</LongDescription>
    <Details>
<![CDATA[
<p> 此方法比较一个表达式，例如<p><pre>(event.detail&amp；SWT.SELECTED)&gt；0)<pre>。
使用位算术，然后与大于运算符进行比较可能会导致意外的结果(当然取决于SWT.SELECTED的值)。如果SWT.SELECTED是负数，则这是bug的候选。
即使SWT.SELECTED不是负的，使用‘！=0’而不是‘&gt；0’似乎也是一种很好的做法。
</p>
<p>
<em>Boris Bokowski</em>
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_AND_ZZ">
    <ShortDescription>检查是否 ((...) &amp; 0) == 0</ShortDescription>
    <LongDescription>检查{1}中是否 ((...) &amp; 0) == 0 </LongDescription>
    <Details>
<![CDATA[
<p>此方法将形式(e&amp；0)的表达式与0进行比较，后者将始终比较相等。这可能表示逻辑错误或打字错误.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BIT_IOR">
    <ShortDescription>不兼容的位掩码</ShortDescription>
<LongDescription>(e|{2}={3})中不兼容的位掩码产生{1}中的常量结果</LongDescription>
    <Details>
<![CDATA[
<p> 该方法将形式（e | C）的表达式与D进行比较，由于常数C和D的特定值，它总是比较不等。
这可能表示逻辑错误或拼写错误.</p>

<p>通常，出现此错误是因为代码想要在位集中执行成员资格测试，但使用按位OR运算符（“|”）而不是按位AND（“＆amp;”）。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_INSTANCE" deprecated="true">
    <!-- never generated? -->
   <ShortDescription>实例字段的懒惰初始化不正确</ShortDescription>
<LongDescription>{1}中实例字段{2}的懒惰初始化不正确</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含非易失性字段的非同步延迟初始化。
因为编译器或处理器可能会重新排序指令，所以不保证线程看到完全初始化的对象，如果该方法可以由多个线程</ em>调用，则<em>。
您可以使字段为volatile以纠正问题。
有关更多信息，请参阅
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_STATIC">
<ShortDescription>静态字段的懒惰初始化和更新不正确</ShortDescription>
<LongDescription>{1}中静态字段{2}的懒惰初始化和更新不正确</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含非易失性静态字段的非同步延迟初始化。
因为编译器或处理器可能会重新排序指令，所以不保证线程看到完全初始化的对象，如果该方法可以由多个线程</ em>调用，则<em>。
您可以使字段为volatile以纠正问题。
有关更多信息，请参阅
<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">Java Memory Model web site</a>.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="LI_LAZY_INIT_UPDATE_STATIC">
       <ShortDescription>静态字段的延迟初始化和更新不正确</ShortDescription>
    <LongDescription>静态字段的延迟初始化和更新不正确 {2} 在 {1}</LongDescription>
    <Details>
<![CDATA[
<p> 此方法包含静态字段的非同步延迟初始化。 设置字段后，将进一步更新或访问存储在该位置的对象。
一旦设置，其他线程就可以看到该字段的设置。 
如果在设置字段的方法中进一步访问以初始化对象，那么您有一个<em>非常严重的</ em>多线程错误，除非其他东西阻止任何其他线程访问存储对象，直到它完全初始化。
</p>
<p>即使您确信该方法永远不会被多个线程调用，但最好不要设置静态字段，直到您将其设置为的值完全填充/初始化为止。
]]>
    </Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_LOCK_MONITORENTER">
    <ShortDescription>在锁定上执行同步</ShortDescription>
<LongDescription>已在{1}中的{2}上执行同步</LongDescription>
    <Details>
<![CDATA[
<p> 此方法执行同步实现java.util.concurrent.locks.Lock的对象。这样的对象是使用<code>获取()<code><code>release()<code>而不是使用<code>synchronized(.)<code>构造锁定解锁的

</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT">
   <ShortDescription>在util.current抽象上使用监视样式的wait方法</ShortDescription>
<LongDescription>在{1}中调用{2.name}而不是{3.name}</LongDescription>
    <Details>
<![CDATA[
<p> 此方法对还提供<code>await()<code>、<code>signal()<code>、<code>signalAll()<code>方法(如util.concurrent condition objects)的对象调用<code>wait()<code>、<code>Notify()<code>或<code>NotifyAll()。
这可能不是您想要的，即使您确实想要，您也应该考虑更改您的设计，因为其他开发人员会发现它特别令人困惑
</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="JLM_JSR166_UTILCONCURRENT_MONITORENTER">
    <ShortDescription>在util.current实例上执行同步</ShortDescription>
<LongDescription>已在{1}中的{2}上执行同步</LongDescription>
    <Details>
<![CDATA[
<p> 此方法执行同步对象，该对象是java.util.current包(或其子类)中的类的实例。这些类的实例有它们自己的并发控制机制，这些机制与Java关键字<code>Synchronized<code>提供的同步正交。
例如，在<code>AtomicBoolean<code>上同步不会阻止其他线程修改<code>AtomicBoolean<code>。</p>
<p>这样的代码可能是正确的，但应该仔细检查和记录，并且可能会使以后必须维护代码的人感到困惑
</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="UPM_UNCALLED_PRIVATE_METHOD">
    <ShortDescription>从不调用私有方法</ShortDescription>
<LongDescription>从未调用私有方法{1}</LongDescription>
    <Details>
<![CDATA[
<p> 从不调用此私有方法。虽然有可能通过反射调用该方法，但更有可能的是从未使用过该方法，应该将其删除
</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS">
   <ShortDescription>匿名类中定义的不可调用方法</ShortDescription>
<LongDescription>匿名类中定义的不可调用方法{1}</LongDescription>
    <Details>
<![CDATA[
<p> 此匿名类定义了一个不直接调用的方法，也不覆盖超类中的方法。
由于其他类中的方法不能直接调用在匿名类中声明的方法，因此该方法似乎是不可调用的。
该方法可能只是死代码，但也有可能该方法旨在覆盖在超类中声明的方法，并且由于键入错误或其他错误，该方法实际上不会覆盖它想要覆盖的方法
</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE">
    <ShortDescription>方法可能无法关闭数据库资源</ShortDescription>
<LongDescription>{1}可能无法关闭{2.excludingPackage}</LongDescription>
    <Details>
<![CDATA[
<p> 方法创建数据库资源(如数据库连接或行集)，不将其分配给任何字段，不将其传递给其他方法或返回它，并且似乎没有关闭该方法的所有路径上的对象。&nbsp；
如果无法关闭方法的所有路径上的数据库资源，可能会导致性能低下，并可能导致应用程序与数据库通信出现问题
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH">
    <ShortDescription>方法在发生异常时可能无法关闭数据库资源</ShortDescription>
<LongDescription>发生异常时{1}可能无法关闭数据库资源</LongDescription>>
    <Details>
<![CDATA[
<p> 方法创建数据库资源(如数据库连接或行集)，不将其分配给任何字段，不将其传递给其他方法或返回它，并且似乎没有关闭该方法的所有异常路径上的对象。&nbsp；
如果无法关闭方法的所有路径上的数据库资源，可能会导致性能低下，并可能导致应用程序与数据库通信出现问题</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SBSC_USE_STRINGBUFFER_CONCATENATION">
    <ShortDescription>方法在循环中使用+连接字符串</ShortDescription>
<LongDescription>{1}在循环中使用+连接字符串</LongDescription>
    <Details>
<![CDATA[
<p> 该方法似乎是在循环中使用连接构建String。在每次迭代中，String被转换为StringBuffer / StringBuilder，附加到并转换回String。
    这可能导致迭代次数的成本二次，因为在每次迭代中重新生成增长的字符串。 </p>

<p>通过显式使用StringBuffer（或Java 1.5中的StringBuilder）可以获得更好的性能。</p>

<p> For example:</p>
<pre>
  // This is bad
  String s = "";
  for (int i = 0; i &lt; field.length; ++i) {
    s = s + field[i];
  }

  // This is better
  StringBuffer buf = new StringBuffer();
  for (int i = 0; i &lt; field.length; ++i) {
    buf.append(field[i]);
  }
  String s = buf.toString();
</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PREPARE_STATEMENT_IN_LOOP">
    <ShortDescription>方法在循环中调用prepaareStatement</ShortDescription>
<LongDescription>{1}在循环中使用常量参数调用preadareStatement</LongDescription>
    <Details>
<![CDATA[
<p> 该方法在传递常量参数的循环中调用Connection.prepreareStatement。如果PreparedStatement应该执行几次，那么没有理由为每个循环迭代重新创建它。将此呼叫移出循环.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_ELEMENTS_GET_LENGTH_IN_LOOP">
    <ShortDescription>在循环中调用NodeList.getLength()</ShortDescription>
<LongDescription>
{1}在getElementsByTagName返回值的循环中调用NodeList.getLength()
</LongDescription>
    <Details>
<![CDATA[
<p> 该方法在循环内调用NodeList.getLength()，并且NodeList由getElementsByTagName调用生成。
这个NodeList不存储它的长度，但是每次都以不是很理想的方式计算它。考虑在循环之前将长度存储到变量中
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP">
    <ShortDescription>方法在循环中调用Pattern.Compile</ShortDescription>
<LongDescription>{1}在循环中使用常量参数调用Pattern.Compile</LongDescription>
    <Details>
<![CDATA[
<p> 该方法在传递常量参数的循环中调用Pattern.Compile。如果模式应该使用几次，那么就没有理由为每个循环迭代编译它。将此调用移出循环，甚至移入静态final字段</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT">
    <ShortDescription>方法在循环中编译正则表达式</ShortDescription>
<LongDescription>{1}在循环中编译正则表达式</LongDescription>
    <Details>
<![CDATA[
<p> 该方法在循环内创建相同的正则表达式，因此每次迭代都会对其进行编译。在循环之外使用Pattern.Compile预编译此正则表达式会更理想</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_INDEX_OF">
    <ShortDescription>String.indexOf(String)的使用效率低下</ShortDescription>
<LongDescription>{1}使用String.indexOf(String)而不是String.indexOf(Int)</LongDescription>
    <Details>
<![CDATA[
<p> This code passes a constant string of length 1 to String.indexOf().
It is more efficient to use the integer implementations of String.indexOf().
f. e. call <code>myString.indexOf('.')</code> instead of <code>myString.indexOf(".")</code></p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IIO_INEFFICIENT_LAST_INDEX_OF">
    <ShortDescription>String.lastIndexOf(String)的使用效率低下</ShortDescription>
<LongDescription>
{1}使用String.lastIndexOf(String)而不是String.lastIndexOf(Int)
</LongDescription>
    <Details>
<![CDATA[
<p> 此代码将长度为1的常量字符串传递给String.lastIndexOf（）。
使用String.lastIndexOf（）的整数实现更有效。
F。即 调用<code> myString.lastIndexOf（'.'）</ code>而不是<code> myString.lastIndexOf（"."）</ code></p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ITA_INEFFICIENT_TO_ARRAY">
    <ShortDescription>方法使用具有零长度数组参数的toArray()</ShortDescription>
<LongDescription>{1}使用具有零长度数组参数的Collection.toArray()</LongDescription>
    <Details>
<![CDATA[
<p> 此方法使用集合派生类的toArray()方法，并传入零长度原型数组参数。
使用<code>myCollection.toArray(new foo[myCollection.size()])<code>更有效。
如果传入的数组足够大，可以存储集合的所有元素，那么它将被填充并直接返回。
这避免了创建第二个数组(通过反射)作为结果返回的需要.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD">
    <ShortDescription>Run方法中的JUnit断言不会被JUnit注意到</ShortDescription>
<LongDescription>{1}中的JUnit断言将不会被JUnit注意到</LongDescription>
    <Details>
<![CDATA[
<p> 在run方法中执行JUnit断言。
失败的JUnit断言只会导致抛出异常。
因此，如果此异常发生在调用测试方法的线程以外的线程中，则异常将终止线程，但不会导致测试失败
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SETUP_NO_SUPER">
   <ShortDescription>TestCase定义了不调用super.setUp()的设置</ShortDescription>
<LongDescription>TestCase{0}定义不调用super.setUp()的设置</LongDescription>
    <Details>
<![CDATA[
<p> Class是JUnit TestCase并实现Setup方法。setup方法应该调用super.setUp()，但没有</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_TEARDOWN_NO_SUPER">
   <ShortDescription>TestCase定义了不调用super.tearDown()的teardown</ShortDescription>
<LongDescription>TestCase{0}定义了不调用super.tearDown()的teardown</LongDescription>
    <Details>
<![CDATA[
<p>Class是JUnit TestCase并实现teardown方法。teardown方法应该调用super.tearDown()，但没有</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_SUITE_NOT_STATIC">
    <ShortDescription>TestCase实现了一个非静态的套件方法</ShortDescription>
<LongDescription>TestCase{0}实现非静态套件方法</LongDescription>
    <Details>
<![CDATA[
<p> Class是JUnit TestCase并实现Suite()方法。Suite方法应该声明为静态，但实际上不是.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_BAD_SUITE_METHOD">
    <ShortDescription>TestCase声明了一个错误的套件方法</ShortDescription>
<LongDescription>{0}中Suite方法的声明错误</LongDescription>
    <Details>
<![CDATA[
<p> Class是JUnit TestCase并定义了Suite()方法。但是，Suite方法需要声明为</p>
<pre>public static junit.framework.Test suite()</pre>
or
<pre>public static junit.framework.TestSuite suite()</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IJU_NO_TESTS">
   <ShortDescription>TestCase没有测试</ShortDescription>
<LongDescription>TestCase{0}没有测试</LongDescription>
    <Details>
<![CDATA[
<p>类是JUnit TestCase，但尚未实现任何测试方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BOA_BADLY_OVERRIDDEN_ADAPTER">
   <ShortDescription>类错误地重写了在超类Adapter中实现的方法</ShortDescription>
<LongDescription>类{0}错误地重写了在超类Adapter中实现的方法{1}</LongDescription>
    <Details>
<![CDATA[
<p> 此方法覆盖在父类中找到的方法，其中该类是实现java.awt.event或javax.swing.event包中定义的侦听器的Adapter。因此，当事件发生时，将不会调用此方法</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BRSA_BAD_RESULTSET_ACCESS" deprecated="true">
    <!-- deprecated in favor of SQL_BAD_RESULTSET_ACCESS -->
    <ShortDescription>方法尝试访问索引为0的结果集字段</ShortDescription>
<LongDescription>{1}尝试访问索引为0的结果集字段</LongDescription>
    <Details>
<![CDATA[
<p> 在字段索引为0的情况下调用了结果集的getXXX或updateXXX方法。由于ResultSet字段从索引%1开始，这始终是一个错误</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_RESULTSET_ACCESS">
    <ShortDescription>方法尝试访问索引为0的结果集字段</ShortDescription>
<LongDescription>{1}尝试访问索引为0的结果集字段</LongDescription>
    <Details>
<![CDATA[
<p> 在字段索引为0的情况下调用了结果集的getXXX或updateXXX方法。由于ResultSet字段从索引%1开始，这始终是一个错误.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SQL_BAD_PREPARED_STATEMENT_ACCESS">
    <ShortDescription>方法尝试访问索引为0的预准备语句参数</ShortDescription>
<LongDescription>{1}尝试访问索引为0的预准备语句参数</LongDescription>>
    <Details>
<![CDATA[
<p> A call to a setXXX method of a prepared statement was made where the
parameter index is 0. As parameter indexes start at index 1, this is always a mistake.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SIO_SUPERFLUOUS_INSTANCEOF">
    <ShortDescription>使用instanceof运算符完成了不必要的类型检查</ShortDescription>
<LongDescription>{1}在可以静态确定的情况下，使用instanceof运算符执行不必要的类型检查</LongDescription>
    <Details>
<![CDATA[
<p> 使用instanceof运算符执行的类型检查，其中可以静态确定对象是否属于请求的类型。 </p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BAC_BAD_APPLET_CONSTRUCTOR">
    <ShortDescription>错误的小程序构造函数依赖于未初始化的AppletStub</ShortDescription>
<LongDescription>错误的小程序构造函数依赖于未初始化的AppletStub</LongDescription>
    <Details>
<![CDATA[
<p>
此构造函数调用父applet中依赖于AppletStub的方法。由于AppletStub在调用此小程序的init()方法之前不会初始化，因此这些方法将无法正确执行
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_ARRAY_AND_NONARRAY">
    <ShortDescription>equals()用于比较数组和非数组</ShortDescription>
<LongDescription>在{1}中调用{3.simpleClass}.equals({2.simpleClass})</LongDescription>>
    <Details>
<![CDATA[
<p>
此方法调用.equals(对象o)来比较数组和似乎不是数组的引用。
如果被比较的东西是不同类型的，它们肯定是不平等的，并且几乎可以肯定比较是错误的。
即使两个数组都是数组，但数组上的equals方法仅确定两个数组是相同的对象。
要比较数组的内容，请使用java.util.Arrays.equals(object[]，object[])
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_BAD_ARRAY_COMPARE">
  <ShortDescription>对数组调用equals()，相当于=</ShortDescription>
<LongDescription>使用.equals比较{1}中的两个{2.simpleClass}，(等效于=)</LongDescription>
    <Details>
<![CDATA[
<p>
此方法对数组调用.equals(Object O)方法。由于数组不重写Object的equals方法，因此对数组调用equals与比较它们的地址是一样的。
要比较数组的内容，请使用<code>java.util.Arrays.equals(object[]，object[])<code>。为了比较数组的地址，使用<code>=<code>显式检查指针相等不会那么混乱
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="EC_INCOMPATIBLE_ARRAY_COMPARE">
    <ShortDescription>等于(.)用于比较不兼容的数组</ShortDescription>
<LongDescription>使用等于比较{1}中的{2.simpleClass}和{3.simpleClass}</LongDescription>
    <Details>
<![CDATA[
<p>
此方法调用.equals(对象o)来比较两个数组，但不兼容类型的数组(例如String[]和StringBuffer[]，或String[]和int[])。他们永远不会平等。
此外，当等于(.)用于比较数组，它只检查它们是否是相同的数组，并忽略数组的内容
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_CURRENTTHREAD">
    <ShortDescription>不必要地使用currentThread()调用，以调用interrupted()</ShortDescription>
<LongDescription>{1}对currentThread()进行不必要的调用，只是为了调用interrupted()</LongDescription>
    <Details>
<![CDATA[
<p>
此方法调用Thread.currentThread()调用，只是为了调用中断的()方法。由于interrupted()是一个静态方法，所以使用Thread.interrupted()更加简单和清晰
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="STI_INTERRUPTED_ON_UNKNOWNTHREAD">
    <ShortDescription>在线程实例上调用的静态Thread.interrupted()方法</ShortDescription>
<LongDescription>{1}对线程实例调用静态Thread.interrupted()方法</LongDescription>
    <Details>
<![CDATA[
<p>
此方法对Thread对象调用Thread.interrupted()方法，该对象似乎是不是当前线程的Thread对象。
由于interrupted()方法是静态的，所以中断的方法将在与作者打算调用的对象不同的对象上调用
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN">
   <ShortDescription>参数在进入方法时失效，但被覆盖</ShortDescription>
<LongDescription>参数{2}到{1}在输入时失效，但被覆盖</LongDescription>>
    <Details>
<![CDATA[
<p>
忽略此参数的初始值，并在此处覆盖该参数。
这通常表明错误地认为对参数的写入将被传递回调用者
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD">
    <ShortDescription>已死存储到阴影字段局部变量</ShortDescription>
<LongDescription>死存储到{2}，而不是{1}中具有相同名称的字段</LongDescription>
    <Details>
<![CDATA[
<p>
此指令为局部变量赋值，但该值不会在任何后续指令中读取或使用。通常，这表明存在错误，因为从未使用计算出的值。
有一个字段与局部变量同名。您的意思是改为赋值给该变量吗？
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE">
    <ShortDescription>局部变量的死存储</ShortDescription>
<LongDescription>{1}中{2}的死存储区</LongDescription>
    <Details>
<![CDATA[
<p>
此指令为局部变量赋值，但该值不会在任何后续指令中读取或使用。通常，这表明存在错误，因为从未使用计算出的值。
</p>
<p>
请注意，Sun的javac编译器经常为最终的局部变量生成死库。
因为FindBugs是基于字节码的工具，所以没有简单的方法来消除这些误报
</p>
]]>
    </Details>
  </BugPattern>

  <BugPattern type="DLS_DEAD_LOCAL_STORE_IN_RETURN">
    <ShortDescription>Useless assignment in return statement</ShortDescription>
    <LongDescription>Useless assignment in return from {1}</LongDescription>
    <Details>
      <![CDATA[
<p>
This statement assigns to a local variable in a return statement. This assignment
has effect. Please verify that this statement does the right thing.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_INCREMENT_IN_RETURN">
   <ShortDescription>return语句中的无用赋值</ShortDescription>
<LongDescription>{1}返回的无用分配</LongDescription>
    <Details>
      <![CDATA[
<p>此语句在return语句中赋值给局部变量。本作业有效。请确认这句话做的是正确的
</p>
]]>
    </Details>
  </BugPattern>



  <BugPattern type="DLS_DEAD_STORE_OF_CLASS_LITERAL">
    <ShortDescription>类文字的死库</ShortDescription>
<LongDescription>{1}中{3}.class的死库</LongDescription>
    <Details>
<![CDATA[
<p>
该指令将类文字分配给变量，然后从不使用它。
<a href="//java.sun.com/j2se/1.5.0/compatibility.html#literal">The behavior of this differs in Java 1.4 and in Java 5.</a>
在Java 1.4及更早版本中，对<code> Foo.class </ code>的引用会强制执行<code> Foo </ code>的静态初始化程序（如果尚未执行）。
在Java 5及更高版本中，它没有。
</p>
<p>在Sun's <a href="//java.sun.com/j2se/1.5.0/compatibility.html#literal">article on Java SE compatibility</a>
上查找更多信息和案例,以及如何在Java 5中强制类初始化的建议。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_DEAD_LOCAL_STORE_OF_NULL">
    <ShortDescription>局部变量NULL的死存储</ShortDescription>
<LongDescription>{1}中空到{2}的死存储区</LongDescription>
    <Details>
<![CDATA[
<p>代码将NULL存储到局部变量中，并且不读取存储的值。引入这个存储可能是为了帮助垃圾收集器，但从Java SE 6.0开始，就不再需要它了，也不再有用了
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_METHOD_MASKS_FIELD">
    <ShortDescription>方法定义了一个隐藏字段的变量</ShortDescription>
<LongDescription>{1}定义了遮蔽字段{2.givenClass}的变量</LongDescription>
    <Details>
<![CDATA[
<p> 此方法定义一个与此类或超类中的字段同名的局部变量。这可能会导致该方法从字段中读取未初始化值，使字段保持未初始化状态，或两者兼而有之。</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="MF_CLASS_MASKS_FIELD">
    <ShortDescription>类定义掩码超类字段的字段</ShortDescription>
<LongDescription>字段{1.givenClass}超类{2.class}中的掩码字段</LongDescription>
    <Details>
<![CDATA[
<p> 此类定义与超类中可见实例字段同名的字段。这是令人迷惑的，并且如果方法需要另一个字段时更新或访问另一个字段，则可能指示错误.</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="WMI_WRONG_MAP_ITERATOR">
    <ShortDescription>使用keyset迭代器代替entrySet迭代器效率低下</ShortDescription>
<LongDescription>{1}使用keyset迭代器而不是entrySet迭代器效率低下</LongDescription>
    <Details>
<![CDATA[
<p> 此方法使用从键集迭代器检索的键访问Map条目的值。
在map的entrySet上使用迭代器更有效，以避免Map.get(Key)查找</p>
]]>
        </Details>
  </BugPattern>
  <BugPattern type="ISC_INSTANTIATE_STATIC_CLASS">
   <ShortDescription>只提供静态方法的类的不必要的实例化</ShortDescription>
<LongDescription>{1}不必要地实例化仅提供静态方法的类</LongDescription>
    <Details>
<![CDATA[
<p> 此类分配的对象基于仅提供静态方法的类。此对象不需要创建，只需使用类名作为限定符直接访问静态方法即可。</p>
]]>
        </Details>
  </BugPattern>
  <BugPattern type="REC_CATCH_EXCEPTION">
    <ShortDescription>在未引发异常时捕获异常</ShortDescription>
<LongDescription>在{1}中未引发异常时捕获异常</LongDescription>
    <Details>
  <![CDATA[
  <p>
  此方法使用捕获异常对象的try-catch块，但在try块内不引发异常，并且不显式捕获RuntimeException。
  将try{.}catch(Exception E){Something}作为捕获各种类型的异常的简写是一种常见的bug模式，每个异常的catch块都是相同的，但是这个构造也意外地捕获了RuntimeException，掩盖了潜在的bug
  </p>
  <p>更好的方法是要么显式捕获抛出的特定异常，要么显式捕获RuntimeException异常，重新抛出它，然后捕获所有非运行时异常，如下所示：</p>
  <pre>
  try {
    ...
  } catch (RuntimeException e) {
    throw e;
  } catch (Exception e) {
    ... deal with all non-runtime exceptions ...
  }</pre>
  ]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER">
    <ShortDescription>对南平等的注定考验</ShortDescription>
<LongDescription>{1}中与NaN相等的注定测试</LongDescription>
    <Details>
   <![CDATA[
    <p>
    此代码检查浮点值是否等于特殊的Not A数值(例如，<code>if(x=Double.NaN)<code>)。
    但是，由于<code>nan<code>的特殊语义，没有一个值等于<code>nan<code>，包括<code>nan<code>。因此，<code>x=Double.NaN<code>始终计算为false。
    若要检查<code>x<code>中包含的值是否为特殊Not A数字值，请使用<code>Double.isNaN(X)<code>(如果<code>x<code>是浮点精度，则使用<code>Float.isNaN(X)<code>)。
    </p>
    ]]>
     </Details>
  </BugPattern>
  <BugPattern type="FE_FLOATING_POINT_EQUALITY">
    <ShortDescription>浮点相等测试</ShortDescription>
<LongDescription>测试{1}中的浮点相等</LongDescription>
    <Details>
   <![CDATA[
    <p>
    此操作比较两个浮点值是否相等。因为浮点计算可能涉及舍入，所以计算的浮点值和双精度值可能不准确。
    对于必须精确的值(如货币值)，请考虑使用固定精度类型，如BigDecimal。
    对于不需要精确的值，考虑在某个范围内比较相等，
    例如：<code>if(Math.abs(x-y)&lt；.0000001)<code>。参见Java语言规范，第4.2.4节
    </p>
    ]]>
     </Details>
  </BugPattern>
  <BugPattern type="UM_UNNECESSARY_MATH">
   <ShortDescription>方法对常量值调用静态数学类方法</ShortDescription>
<LongDescription>方法对常量值调用静态数学类方法</LongDescription>
    <Details>
<![CDATA[
<p> This method uses a static method from java.lang.Math on a constant value. This method's
result in this case, can be determined statically, and is faster and sometimes more accurate to
just use the constant. Methods detected are:
</p>
<table>
<tr>
   <th>Method</th> <th>Parameter</th>
</tr>
<tr>
   <td>abs</td> <td>-any-</td>
</tr>
<tr>
   <td>acos</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>asin</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>atan</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>atan2</td> <td>0.0</td>
</tr>
<tr>
   <td>cbrt</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>ceil</td> <td>-any-</td>
</tr>
<tr>
   <td>cos</td> <td>0.0</td>
</tr>
<tr>
   <td>cosh</td> <td>0.0</td>
</tr>
<tr>
   <td>exp</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>expm1</td> <td>0.0</td>
</tr>
<tr>
   <td>floor</td> <td>-any-</td>
</tr>
<tr>
   <td>log</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>log10</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>rint</td> <td>-any-</td>
</tr>
<tr>
   <td>round</td> <td>-any-</td>
</tr>
<tr>
   <td>sin</td> <td>0.0</td>
</tr>
<tr>
   <td>sinh</td> <td>0.0</td>
</tr>
<tr>
   <td>sqrt</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>tan</td> <td>0.0</td>
</tr>
<tr>
   <td>tanh</td> <td>0.0</td>
</tr>
<tr>
   <td>toDegrees</td> <td>0.0 or 1.0</td>
</tr>
<tr>
   <td>toRadians</td> <td>0.0</td>
</tr>
</table>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="CD_CIRCULAR_DEPENDENCY">
    <ShortDescription>测试类之间的循环依赖关系</ShortDescription>
<LongDescription>类{0}与其他类有循环依赖关系</LongDescription>
    <Details>
   <![CDATA[
    <p>
    此类与其他类有循环依赖关系。这使得构建这些类变得困难，因为每个类都依赖于其他类才能正确构建。考虑使用接口来打破硬依赖
    </p>
    ]]>
     </Details>
  </BugPattern>
  <BugPattern type="RI_REDUNDANT_INTERFACES">
    <ShortDescription>类实现与超类相同的接口</ShortDescription>
<LongDescription>类{0}实现与超类相同的接口</LongDescription>
    <Details>
   <![CDATA[
    <p>
    此类声明它实现了一个接口，该接口也是由超类实现的。这是多余的，因为一旦一个超类实现了一个接口，默认情况下所有的子类也会实现这个接口。
    它可能会指出，自从创建这个类以来，继承层次结构已经发生了变化，应该考虑接口实现的所有权
    </p>
    ]]>
     </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_STRUTS_INSTANCE_FIELD">
    <ShortDescription>类扩展Struts Action类并使用实例变量</ShortDescription>
<LongDescription>类{0}扩展Struts Action类并使用实例变量</LongDescription>
    <Details>
   <![CDATA[
    <p>
    此类从Struts Action类扩展，并使用实例成员变量。
    由于Struts框架只创建了Struts Action类的一个实例，并以多线程的方式使用，因此这种范例非常不受欢迎，而且很可能会出现问题。
    只考虑使用方法局部变量。仅报告在监视器外部写入的实例字段
    </p>
    ]]>
      </Details>
  </BugPattern>
  <BugPattern type="MTIA_SUSPECT_SERVLET_INSTANCE_FIELD">
    <ShortDescription>类扩展Servlet类并使用实例变量</ShortDescription>
<LongDescription>类{0}扩展Servlet类并使用实例变量</LongDescription>
    <Details>
   <![CDATA[
    <p>
    此类从Servlet类扩展，并使用实例成员变量。由于一个Servlet类只有一个实例是由J2EE框架创建的，并以多线程的方式使用，因此这种范例非常不受欢迎，而且很可能会出现问题。只考虑使用方法局部变量
    </p>
    ]]>
      </Details>
  </BugPattern>
  <BugPattern type="PS_PUBLIC_SEMAPHORES">
    <ShortDescription>类在其公共接口中公开同步和信号量</ShortDescription>
<LongDescription>类{0}在其公共接口中公开同步和信号量</LongDescription>
    <Details>
   <![CDATA[
    <p>
    此类将同步与wait()、Notify()或NotifyAll()一起对自身(this引用)使用。
    此外，使用此类的客户端类还可以将此类的实例用作同步对象。
    因为两个类使用相同的对象进行同步，所以多线程正确性是可疑的。不应对公共引用进行同步或调用信号量方法。
    考虑使用内部私有成员变量来控制同步
    </p>
    ]]>
      </Details>
  </BugPattern>
  <BugPattern type="ICAST_INTEGER_MULTIPLY_CAST_TO_LONG">
   <ShortDescription>整数乘法强制转换为LONG的结果</ShortDescription>
<LongDescription>在{1}中将整数乘法强制转换为LONG的结果</LongDescription>
    <Details>
<![CDATA[
<p>
此代码执行整数乘法，然后将结果转换为long，如下所示：</p>
<pre>
    long convertDaysToMilliseconds(int days) { return 1000*3600*24*days; }
</pre>
<p>
如果使用长算术完成乘法，则可以避免结果溢出的可能性。 例如，您可以将上述代码修复为：</p>
<pre>
    long convertDaysToMilliseconds(int days) { return 1000L*3600*24*days; }
</pre>
or
<pre>
    static final long MILLISECONDS_PER_DAY = 24L*3600*1000;
    long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }
</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_2_LONG_AS_INSTANT">
   <ShortDescription>INT值转换为LONG并用作绝对时间</ShortDescription>
<LongDescription>int转换为long并作为绝对时间传递给{1}中的{2}</LongDescription>
    <Details>
<![CDATA[
<p>
此代码将32位int值转换为64位长值，然后将该值传递给需要绝对时间值的方法参数。
绝对时间值是自标准基准时间（称为“纪元”）以来的毫秒数，即1970年1月1日00:00:00 GMT。
例如，以下方法旨在将自纪元以来的秒数转换为日期，这一方法严重受损:</p>
<pre>
Date getDate(int seconds) { return new Date(seconds * 1000); }
</pre>
<p>乘法使用32位算术完成，然后转换为64位值。
当32位值转换为64位并用于表示绝对时间值时，只能表示1969年12月和1970年1月的日期。</p>

<p>Correct implementations for the above method are:</p>

<pre>
// Fails for dates after 2037
Date getDate(int seconds) { return new Date(seconds * 1000L); }

// better, works for all dates
Date getDate(long seconds) { return new Date(seconds * 1000); }
</pre>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND">
    <ShortDescription>int值强制转换为float，然后传递给Math.round</ShortDescription>
<LongDescription>Int值强制转换为Float，然后传递给{1}中的Math.round</LongDescription>
    <Details>
<![CDATA[
<p>
此代码将int值转换为浮点精度浮点数，然后将结果传递给Math.round()函数，该函数返回最接近参数的intlong。
这个操作应该始终是no-op，因为将整数转换为float应该给出一个没有小数部分的数字。
生成要传递给Math.round的值的操作很可能是打算使用浮点算术执行的
</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL">
    <ShortDescription>整数值转换为Double，然后传递给Math.ceil</ShortDescription>
<LongDescription>整数值转换为Double，然后传递给{1}中的Math.ceil</LongDescription>
    <Details>
<![CDATA[
<p>
此代码将整数值(例如int或long)转换为双精度浮点数，然后将结果传递给Math.ceil()函数，该函数将双精度四舍五入到下一个较高的整数值。
这个操作应该始终是no-op，因为将整数转换为double应该给出一个没有小数部分的数字。
生成要传递给Math.ceil的值的操作很可能是打算使用双精度浮点算术来执行的
</p>

]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_IDIV_CAST_TO_DOUBLE">
    <ShortDescription>整除结果强制转换为double或float</ShortDescription>
<LongDescription>整数除法结果在{1}中强制转换为Double或Float</LongDescription>>
    <Details>
<![CDATA[
<p>
此代码将整数除法(例如，int或long除法)运算的结果强制转换为double或float。
对整数进行除法会将结果截断为最接近零的整数值。结果被强制转换为Double这一事实表明，应该保留这种精确度。可能的意思是在<em>执行除法之前，将一个或两个操作数强制转换为double<em>。
下面是一个示例：
</p>
<blockquote>
<pre>
int x = 2;
int y = 5;
// Wrong: yields result 0.0
double value1 =  x / y;

// Right: yields result 0.4
double value2 =  x / (double) y;
</pre>
</blockquote>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION">
    <ShortDescription>将不可序列化对象存储到HttpSession中</ShortDescription>
<LongDescription>将不可序列化的{2}存储到{1}中的HttpSession中</LongDescription>
    <Details>
<![CDATA[
<p>
此代码似乎正在将不可序列化的对象存储到HttpSession中。如果此会话被钝化或迁移，将导致错误
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_NONSERIALIZABLE_OBJECT_WRITTEN">
    <ShortDescription>写入ObjectOutput的不可序列化对象</ShortDescription>
<LongDescription>不可序列化的{2}写入{1}中的ObjectOutput</LongDescription>>
    <Details>
<![CDATA[
<p>
此代码似乎正在将不可序列化的对象传递给ObjectOutput.writeObject方法。如果对象确实是不可序列化的，则会产生错误
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT">
    <ShortDescription>格式字符串没有以前的参数</ShortDescription>
<LongDescription>{1}中{2}的格式字符串参数没有以前的参数</LongDescription>
    <Details>
<![CDATA[
<p>
格式字符串指定一个相对索引，用于请求重用前一格式说明符的参数。 但是，之前没有争论。
例如，
</p>
<p><code>formatter.format("%&lt;s %s", "a", "b")</code>
</p>
<p>would throw a MissingFormatArgumentException when executed.
</p>
]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_USES_NEWLINE">
    <ShortDescription>格式字符串应使用%n而不是</ShortDescription>
<LongDescription>格式字符串应使用%n，而不是在{1}中</LongDescription>
    <Details>
<![CDATA[
<p>
此格式字符串包括换行符()。在格式化字符串中，通常最好使用%n，它将生成特定于平台的行分隔符.
</p>
]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_BAD_CONVERSION">
    <ShortDescription>提供的参数的类型与格式说明符不匹配</ShortDescription>
<LongDescription>{1}中的格式说明符{4}无法处理{3}类型的参数</LongDescription>
    <Details>
<![CDATA[
<p>
其中一个参数与相应的格式字符串说明符不兼容。
因此，这将在执行时生成运行时异常。
例如，<code> String.format（“％d”，“1”）</ code>将生成异常，因为字符串“1”与格式说明符％d不兼容。
</p>
]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN">
    <ShortDescription>使用%b格式说明符格式化的非布尔参数</ShortDescription>
<LongDescription>使用{1}中的%b格式说明符格式化的非布尔参数</LongDescription>
    <Details>
<![CDATA[
<p>
正在使用%b格式说明符格式化非Boolean类型的参数。这不会抛出异常；相反，对于任何非NULL值，它都将输出TRUE，而对于NULL，它将输出FALSE。格式字符串的这个特性很奇怪，可能不是您想要的
</p>
]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_BAD_CONVERSION_FROM_ARRAY">
    <ShortDescription>使用格式字符串以无用的方式格式化的数组</ShortDescription>
<LongDescription>{1}中以无效方式格式化的{3}类型的参数</LongDescription>
    <Details>
<![CDATA[
<p>
使用格式字符串格式化的参数之一是数组。这将使用一种相当无用的格式进行格式化，例如[i@304282，它实际上并不显示数组的内容。
在将数组处理为格式化之前，请考虑使用<code>Arrays.asList(.)<code>包装数组
</p>
]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_ARG_MISMATCH">
    <ShortDescription>格式字符串参数的数量与占位符的数量不对应</ShortDescription>
    <LongDescription>格式字符串方法{2}和格式字符串“{3}”一起被调用想要争议{4}但是在{1}中给了{5}</LongDescription>
    <Details>
<![CDATA[
<p>
调用具有可变参数数量的format-string方法，但传递的参数数量与格式字符串中%占位符的数量不匹配。这可能不是作者的本意
</p>
]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED">
    <ShortDescription>在需要printf样式格式的地方提供MessageFormat</ShortDescription>
<LongDescription>{2}需要printf样式格式，但使用MessageFormat调用</LongDescription>
    <Details>
<![CDATA[
<p>
调用了一个方法，该方法需要Java printf格式字符串和参数列表。
但是，格式字符串不包含任何格式说明符(例如，%s)，但包含消息格式元素(例如，{0})。当需要printf样式的格式字符串时，代码很可能提供了MessageFormat字符串。
在运行时，所有参数都将被忽略，格式字符串将完全按照提供的方式返回，而不会进行任何格式化
</p>
]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED">
    <ShortDescription>传递的参数比格式字符串中实际使用的参数多</ShortDescription>
    <LongDescription>Format-string method {2} called with format string "{3}" wants {4} arguments but is given {5} in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
调用具有可变数量的参数的format-string方法，但传递的参数比格式字符串实际使用的参数多。
这不会导致运行时异常，但代码可能会悄悄地省略格式化字符串中应该包含的信息
</p>
]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_ILLEGAL">
    <ShortDescription>非法格式字符串</ShortDescription>
    <LongDescription>Illegal format string "{3}" in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
格式字符串在语法上无效，执行此语句时将发生运行时异常
</p>
]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_MISSING_ARGUMENT">
    <ShortDescription>格式字符串引用缺少参数</ShortDescription>
    <LongDescription>Format string "{3}" needs argument {5} but only {6} are provided in {1}</LongDescription>
    <Details>
<![CDATA[
<p>
传递的参数不足，无法满足格式字符串中的占位符。执行此语句时将发生运行时异常
</p>
]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_FORMAT_STRING_BAD_ARGUMENT">
 <ShortDescription>格式字符串占位符与传递的参数不兼容</ShortDescription>
<LongDescription>占位符{4}与{1}中的相应参数不兼容</LongDescription>
    <Details>
<![CDATA[
<p>
格式字符串占位符与相应的参数不兼容。 例如，
<code>
  System.out.println("%d\n", "hello");
</code>
<p>％d占位符需要数字参数，而是传递字符串值。
执行此语句时将发生运行时异常。
</p>
]]>
     </Details>
  </BugPattern>
  <BugPattern type="VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG">
    <ShortDescription>传递给函数的基元数组需要可变数量的对象参数</ShortDescription>
<LongDescription>{2}传递给{1}中的varargs方法{3}</LongDescription>
    <Details>
<![CDATA[
<p>
此代码将基元数组传递给接受可变数量的对象参数的函数。这将创建一个长度为1的数组来保存基元数组，并将其传递给函数
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS">
    <ShortDescription>equals方法不应假定其参数的类型</ShortDescription>
<LongDescription>{0}的Equals方法假定参数的类型为{0.givenClass}</LongDescription>>
    <Details>
<![CDATA[
<p>
<code>equals(Object O)<code>方法不应对<code>o<code>的类型做出任何假设。
如果<code>o<code>与<code>this<code>不是相同的类型，它应该简单地返回false
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_ABSTRACT_COLLECTION">
    <ShortDescription>可疑的转换为抽象集合</ShortDescription>
<LongDescription>{1}中从集合到抽象类{3}的转换有问题</LongDescription>
    <Details>
<![CDATA[
<p>
此代码将Collection强制转换为抽象集合(如<code>list<code>、<code>set<code>或<code>Map<code>)。确保对象是您要强制转换到的类型。
如果您只需要能够遍历集合，则不需要将其强制转换为集合或列表
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST_PRIMITIVE_ARRAY">
    <ShortDescription>涉及基元数组的不可能强制转换</ShortDescription>
<LongDescription>{1}中涉及基元数组的不可能强制转换</LongDescription>
    <Details>
<![CDATA[
<p>
此强制转换将始终引发ClassCastException
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_CAST">
   <ShortDescription>不可能的铸型</ShortDescription>
<LongDescription>无法在{1}中从{2}转换为{3}</LongDescription>
    <Details>
<![CDATA[
<p>
此强制转换将始终引发ClassCastException。
FindBugs跟踪instanceof检查的类型信息，还使用关于从方法返回和从字段加载的值类型的更精确的信息。
因此，它可能具有比仅声明的变量类型更精确的信息，并且可以使用它来确定强制转换将总是在运行时抛出异常。

</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST">
    <ShortDescription>不可能的下沉</ShortDescription>
<LongDescription>在{1}中无法从{2}向下转换为{3}</LongDescription>
    <Details>
<![CDATA[
<p>
此强制转换将始终引发ClassCastException。
分析认为它知道正在转换的值的确切类型，试图将其降级为子类型的尝试总是会通过抛出ClassCastException而失败
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY">
    <ShortDescription>toArray()结果的无法向下转换</ShortDescription>
<LongDescription>无法将toArray()结果向下转换为{1}中的{3}</LongDescription>
    <Details>
<![CDATA[
<p>
此代码将对集合调用<code> toArray（）</ code>的结果转换为比<code> Object [] </ code>更具体的类型，如：:</p>
<pre>
String[] getAsArray(Collection&lt;String&gt; c) {
  return (String[]) c.toArray();
  }
</pre>
<p>抛出ClassCastException通常会失败。 几乎所有集合的<code> toArray（）</ code>都返回<code> Object [] </ code>。 
它们不能真正做任何其他事情，因为Collection对象没有引用集合的声明泛型类型。
<p>使用从集合中获取特定类型数组的正确方法 <code>c.toArray(new String[]);</code>
  或 <code>c.toArray(new String[c.size()]);</code> (the latter is slightly more efficient).
<p>这有一个常见/已知异常例外。 <code> Arrays.asList（...）</ code>返回的列表的<code> toArray（）</ code>方法将返回一个covariantly类型的数组。 
例如，<code> Arrays.asArray（new String [] {“a”}）。toArray（）</ code>将返回<code> String [] </ code>。 
FindBugs尝试检测并抑制此类情况，但可能会错过一些。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_NULL_INSTANCEOF">
    <ShortDescription>检查已知的空值以查看它是否是类型的实例</ShortDescription>
<LongDescription>检查已知的空值，以查看它是否是{1}中{2}的实例</LongDescription>
    <Details>
<![CDATA[
<p>
this instanceof test将始终返回false，因为所检查的值保证为NULL。虽然这是安全的，但要确保它不是某种误解或其他逻辑错误的迹象
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_NULL_INSTANCEOF" deprecated="true">
    <!-- deprecated in favor of NP_NULL_INSTANCEOF -->
    <ShortDescription>检查已知的空值以查看它是否是类型的实例</ShortDescription>
<LongDescription>检查已知的空值，以查看它是否是{1}中{2}的实例</LongDescription>
    <Details>
<![CDATA[
<p>
this instanceof test将始终返回false，因为所检查的值保证为NULL。虽然这是安全的，但要确保它不是某种误解或其他逻辑错误的迹象
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_IMPOSSIBLE_INSTANCEOF">
    <ShortDescription>instanceof将始终返回false</ShortDescription>
<LongDescription>instanceof在{1}中将始终返回false，因为{2}不能是{3}</LongDescription>
    <Details>
<![CDATA[
<p>
这个 instanceof test将始终返回false。虽然这是安全的，但要确保它不是某种误解或其他逻辑错误的迹象。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_VACUOUS_INSTANCEOF">
   <ShortDescription>instanceof将始终返回true</ShortDescription>
<LongDescription>instanceof对于{1}中的所有非null值将始终返回true，因为所有{2}都是{3}的实例</LongDescription>
    <Details>
<![CDATA[
<p>
instanceof test将始终返回TRUE(除非正在测试的值为NULL)。
虽然这是安全的，但要确保它不是某种误解或其他逻辑错误的迹象。
如果您真的希望测试值是否为NULL，也许更清楚的做法是进行NULL测试，而不是instanceof测试
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_UNCONFIRMED_CAST">
    <ShortDescription>未检查未确认的铸造</ShortDescription>
<LongDescription>未检查{1}中从{2}到{3}的未确认转换</LongDescription>
    <Details>
<![CDATA[
<p>
此强制转换未选中，并且并非从中强制转换的类型的所有实例都可以强制转换为它要强制转换到的类型。检查您的程序逻辑以确保此强制转换不会失败
</p>
]]>
    </Details>
  </BugPattern>
   <BugPattern type="BC_UNCONFIRMED_CAST_OF_RETURN_VALUE">
  <ShortDescription>uncheckedunconfirmed强制转换方法的返回值</ShortDescription>
<LongDescription>未检查从{1}中返回值的{2}到{3}的未确认强制转换</LongDescription>
    <Details>
<![CDATA[
<p>
此代码对方法的返回值执行未检查的强制转换。
代码可能以保证强制转换是安全的方式调用该方法，但FindBugs无法验证强制转换是否安全。
检查您的程序逻辑以确保此强制转换不会失败
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BC_BAD_CAST_TO_CONCRETE_COLLECTION">
    <ShortDescription>可疑的具体的收藏夹</ShortDescription>
<LongDescription>{1}中从{2}到{3}的转换有问题</LongDescription>
    <Details>
<![CDATA[
<p>
此代码将抽象集合(如Collection、List或Set)强制转换为特定的具体实现(如ArrayList或HashSet)。这可能是不正确的，并且可能会使您的代码变得脆弱，因为这会使将来更难切换到其他具体实现。
除非有特殊的原因，否则只需使用抽象集合类
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_POSSIBLE_UNINTENDED_PATTERN">
    <ShortDescription>在正则表达式里使用"." 或 "|"</ShortDescription>
    <LongDescription>在{1}的正则表达式里使用"." 或 "|"</LongDescription>
    <Details>
<![CDATA[
<p>
正在调用String函数并且“。” 或“|” 正被传递给一个以正则表达式作为参数的参数。 这是你的意图吗？
例如
<li>s.replaceAll(".", "/") will return a String in which <em>every</em> character has been replaced by a '/' character
<li>s.split(".") <em>always</em> returns a zero length array of String
<li>"ab|cd".replaceAll("|", "/") will return "/a/b/|/c/d/"
<li>"ab|cd".split("|") will return array with six (!) elements: [, a, b, |, c, d]
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION">
    <ShortDescription>正则表达式的语法无效</ShortDescription>
<LongDescription>{1}中正则表达式的语法无效</LongDescription>>
    <Details>
<![CDATA[
<p>
此处的代码使用的正则表达式根据正则表达式的语法是无效的。
此语句将在执行时引发PatternSyntaxException
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION">
   <ShortDescription>用于正则表达式的文件.分隔符</ShortDescription>
<LongDescription>文件.分隔符用于{1}中的正则表达式</LongDescription>
    <Details>
<![CDATA[
<p>
这里的代码使用<code> File.separator </ code>
其中需要正则表达式。 这将在Windows平台上失败，其中<code> File.separator </ code>是反斜杠，在正则表达式中将其解释为转义字符。
 还有其他选择，你可以使用
<code>File.separatorChar=='\\' ? "\\\\" : File.separator</code> 
而不是 <code>File.separator</code>

</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DLS_OVERWRITTEN_INCREMENT">
    <ShortDescription>覆盖增量</ShortDescription>
<LongDescription>覆盖{1}中的增量</LongDescription>
    <Details>
<![CDATA[
<p>
代码执行增量操作(例如，<code>i+<code>)，然后立即覆盖它。
例如，<code>i=i+<code>立即用原始值覆盖递增的值
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT">
    <ShortDescription>无符号右移转换为短字节</ShortDescription>
<LongDescription>{1}中的无符号右移转换为短字节</LongDescription>
    <Details>
<![CDATA[
<p>
代码执行无符号右移位，然后将结果强制转换为短或字节，从而丢弃结果的高位。
由于高位被丢弃，有符号和无符号右移之间可能没有区别(取决于移位的大小)
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="BSHIFT_WRONG_ADD_PRIORITY">
    <ShortDescription>移位操作的解析可能不正确</ShortDescription>
<LongDescription>{1}中的移位操作的分析可能错误</LongDescription>
    <Details>
<![CDATA[
<p>
代码执行类似于(x&lt；&lt；8+y)的操作。
虽然这可能是正确的，但它可能是为了执行(x&lt；&lt；8)+y，
但是Shift操作的优先级较低，因此它实际上被解析为x&lt；&lt；(8+y)
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="ICAST_BAD_SHIFT_AMOUNT">
    <ShortDescription>32位int移位量不在-31.31范围内</ShortDescription>
<LongDescription>32位整数移位{1}中的{2}位</LongDescription>>
    <Details>
<![CDATA[
<p>
代码执行32位int的移位-31.31范围外的常量。
这样做的效果是使用整数值的低5位来决定移位多少(例如，移位40位等同于移位8位，移位32位等同于移位0位)。
这可能不是预期的，而且至少是令人困惑的
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_MULTIPLYING_RESULT_OF_IREM">
    <ShortDescription>整数余数结果的整数乘法</ShortDescription>
<LongDescription>{1}中整数余数结果的整数倍</LongDescription>
    <Details>
<![CDATA[
<p>
代码将剩余整数的结果乘以整数常量。确保没有混淆运算符的优先顺序。例如，I%60*1000是(I%60)*1000，而不是I%(60*1000)
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_HASHCODE_ON_ARRAY">
 <ShortDescription>在数组上调用hashCode</ShortDescription>
<LongDescription>在{1}中对数组调用hashCode</LongDescription>
    <Details>
<![CDATA[
<p>
代码调用数组上的hashCode。
对数组调用hashCode将返回与System.identity HashCode相同的值，并获取数组的内容和长度。
如果需要依赖于数组<code>a<code>的hashCode，请使用<code>java.util.Arrays.hashCode(A)<code>

</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ARRAY">
   <ShortDescription>对数组调用toString</ShortDescription>
<LongDescription>在{1}中的{2.givenClass}上调用toString</LongDescription>>
    <Details>
<![CDATA[
<p>
代码在数组上调用toString，这将生成一个相当无用的结果，如[C@16f0472]。考虑使用Arrays.toString将数组转换为提供数组内容的可读字符串。
请参阅Programming Puzzlers，第3章，谜题12。
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY">
    <ShortDescription>对未命名数组调用toString</ShortDescription>
<LongDescription>在{1}中对未命名数组调用toString</LongDescription>
    <Details>
<![CDATA[
<p>
代码调用(匿名)数组上的toString。对数组调用toString会生成一个相当无用的结果，如[C@16f0472]。考虑使用Arrays.toString将数组转换为提供数组内容的可读字符串。
请参阅Programming Puzzlers，第3章，谜题12
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_AVERAGE_COMPUTATION_COULD_OVERFLOW">
   <ShortDescription>平均数计算可能溢出</ShortDescription>
<LongDescription>平均值的计算可能会在{1}中溢出</LongDescription>
    <Details>
<![CDATA[
<p>代码使用除法或有符号右移计算两个整数的平均值，然后将结果用作数组的索引。
如果平均值非常大，则会溢出（导致计算负平均值）。 
假设结果是非负的，则可以使用无符号右移。 换句话说，而不是使用<code>（低+高）/ 2 </ code>，使用<code>（低+高）＆gt;＆gt;＆gt;1</代码>
</p>
<p>许多早期的二进制搜索和合并排序实现中存在此错误
Martin Buchholz <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6412541">found and fixed it</a>
在JDK图书馆, 和 Joshua Bloch
<a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">widely
publicized the bug pattern</a>.
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="IM_BAD_CHECK_FOR_ODD">
    <ShortDescription>检查对负数不起作用的奇怪情况</ShortDescription>
<LongDescription>检查对{1}中的负数不起作用的奇怪情况</LongDescription>
    <Details>
<![CDATA[
<p>
代码使用x%2=1检查值是否为奇数，但这对负数不起作用(例如，(-5)%2=-1)。如果此代码打算检查异常，请考虑使用x&amp；1=1或x%2！=0
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_HARDCODED_ABSOLUTE_FILENAME">
    <ShortDescription>代码包含对绝对路径名的硬编码引用</ShortDescription>
<LongDescription>{1}中对绝对路径名的硬编码引用</LongDescription>
    <Details>
<![CDATA[
<p>此代码使用硬编码为绝对路径名构造File对象
(e.g., <code>new File("/home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment");</code>
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_BAD_MONTH">
    <ShortDescription>月份的常数值不正确</ShortDescription>
<LongDescription>{2}的错误月份值传递给{1}中的{3}</LongDescription>
    <Details>
<![CDATA[
<p>
此代码将超出预期范围0..11的常量月份值传递给方法
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_USELESS_SUBSTRING">
    <ShortDescription>调用子字符串(0)，返回原始值</ShortDescription>
<LongDescription>{1}调用子字符串(0)，返回原始值</LongDescription>
    <Details>
<![CDATA[
<p>
此代码对字符串调用substring(0)，该字符串返回原始值
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_CALLING_NEXT_FROM_HASNEXT">
    <ShortDescription>hasNext方法调用Next</ShortDescription>
<LongDescription>{1}调用{2.givenClass}</LongDescription>
    <Details>
<![CDATA[
<p>
hasNext()方法调用next()方法。这几乎肯定是错误的，因为hasNext()方法不应该改变迭代器的状态，而下一个方法应该改变迭代器的状态
</p>
]]>
    </Details>
  </BugPattern>
  <BugPattern type="SWL_SLEEP_WITH_LOCK_HELD">
<ShortDescription>方法在持有锁的情况下调用Thread.sleep()</ShortDescription>
<LongDescription>{1}在持有锁的情况下调用Thread.sleep()</LongDescription>
    <Details>
      <![CDATA[
      <p>
      此方法在持有锁的情况下调用Thread.sleep()。
      这可能会导致非常差的性能和可伸缩性，或者出现死锁，因为其他线程可能正在等待获取锁。
      对锁调用wait()是一个更好的主意，这样可以释放锁并允许其他线程运行
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_BRANCHES">
    <ShortDescription>方法对两个分支使用相同的代码</ShortDescription>
<LongDescription>{1}对两个分支使用相同的代码</LongDescription>
    <Details>
      <![CDATA[
      <p>
      此方法使用相同的代码实现条件分支的两个分支。检查以确保这不是编码错误
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="DB_DUPLICATE_SWITCH_CLAUSES">
    <ShortDescription>方法对两个switch子句使用相同的代码</ShortDescription>
<LongDescription>{1}对两个switch子句使用相同的代码</LongDescription>
    <Details>
      <![CDATA[
      <p>
      此方法使用相同的代码来实现switch语句的两个子句。这可能是重复代码的情况，但也可能表明编码错误
      </p>
      ]]>
   </Details>
  </BugPattern>
  <BugPattern type="IMA_INEFFICIENT_MEMBER_ACCESS">
    <ShortDescription>方法访问所属类的私有成员变量</ShortDescription>
<LongDescription>{1}访问所属类的私有成员变量</LongDescription>
    <Details>
      <![CDATA[
      <p>
      内部类的此方法读取或写入所属类的私有成员变量，或调用所属类的私有方法。编译器必须生成一个特殊的方法来访问这个私有成员，这会导致效率降低。
      放松对成员变量或方法的保护将允许编译器将其视为正常访问。
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="XFB_XML_FACTORY_BYPASS">
    <ShortDescription>方法直接分配xml接口的特定实现。</ShortDescription>
<LongDescription>{1}直接分配XML接口的特定实现</LongDescription>
    <Details>
      <![CDATA[
      <p>
      此方法分配XML接口的特定实现。最好使用提供的工厂类来创建这些对象，以便可以在运行时更改实现。有关详细信息，请参阅
      </p>
      <ul>
         <li>javax.xml.parsers.DocumentBuilderFactory</li>
         <li>javax.xml.parsers.SAXParserFactory</li>
         <li>javax.xml.transform.TransformerFactory</li>
         <li>org.w3c.dom.Document.create<i>XXXX</i></li>
      </ul>
      <p>for details.</p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_SUBCLASS_METHOD">
    <ShortDescription>方法多余地委托给父类方法</ShortDescription>
<LongDescription>{1}多余地委托给父类方法</LongDescription>
    <Details>
      <![CDATA[
      <p>
      此派生方法仅调用相同的超类方法，传入接收到的确切参数。可以删除此方法，因为它不提供附加值
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="USM_USELESS_ABSTRACT_METHOD">
    <ShortDescription>抽象方法已在实现的接口中定义</ShortDescription>
<LongDescription>抽象方法{1}已在实现的接口中定义</LongDescription>
    <Details>
      <![CDATA[
      <p>
      此抽象方法已在此抽象类实现的接口中定义。可以删除此方法，因为它不提供附加值
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="CI_CONFUSED_INHERITANCE">
    <ShortDescription>类是final，但声明了受保护的字段</ShortDescription>
<LongDescription>类{0}是final，但声明了受保护的字段{1}</LongDescription>
    <Details>
      <![CDATA[
      <p>
     此类声明为final，但声明了要保护的字段。由于该类是final类，因此不能从其派生，并且protected的使用令人迷惑。
     字段的访问修饰符应该更改为private或public，以表示字段的真正用途
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT">
    <ShortDescription>方法在布尔表达式中赋值布尔文字</ShortDescription>
<LongDescription>{1}在布尔表达式中分配布尔文字</LongDescription>
    <Details>
      <![CDATA[
      <p>
      此方法将文本布尔值(true或false)分配给if或while表达式中的布尔变量。最有可能的是，这应该是使用=的布尔比较，而不是使用=的赋值
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="VR_UNRESOLVABLE_REFERENCE">
    <ShortDescription>类引用无法解析的类或方法</ShortDescription>
<LongDescription>{0}对{1}的引用无法解析</LongDescription>
    <Details>
      <![CDATA[
      <p>
      此类引用无法根据正在分析的库解析的类或方法
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNCHECKED_TYPE_IN_GENERIC_CALL">
    <ShortDescription>泛型调用中未选中的类型</ShortDescription>
<LongDescription>提供的类型Object的未经检查的参数，其中类型{3.givenClass}应在{1}中</LongDescription>
    <Details>
     <![CDATA[
     <p> 此对泛型集合方法的调用在编译类型对象时传递参数，其中需要泛型类型参数中的特定类型。
     因此，标准Java类型系统和静态分析都不能提供关于作为参数传递的对象是否属于适当类型的有用信息
    </p>
     ]]>
    </Details>
  </BugPattern>
  <BugPattern type="GC_UNRELATED_TYPES">
    <ShortDescription>泛型参数和方法参数之间没有关系</ShortDescription>
<LongDescription>{2.givenClass}与{1}中的预期参数类型{3.givenClass}不兼容</LongDescription>
    <Details>
     <![CDATA[
     <p> 此对泛型集合方法的调用包含一个参数，其类与集合的参数的类不兼容(即，参数的类型既不是相应的泛型类型参数的超类型，也不是相应的泛型类型参数的子类型)。
     因此，集合不太可能包含与此处使用的方法参数相等的任何对象。很可能是传递给方法的值错误</p>
    <p>通常，两个不相关的类的实例不相等。例如，如果<code>foo<code>和<code>Bar<code>类不和子类型相关，则<code>foo<code>的实例不应等于<code>Bar<code>的实例。在其他问题中，这样做可能会导致不对称的equals方法。
    例如，如果定义<code>foo<code>类，使<code>foo<code>可以等于<code>字符串<code>，则equals方法不对称，因为<code>字符串<code>只能等于<code>字符串<code>。
    </p>
    <p>在极少数情况下，人们确实定义了非对称的equals方法，并且仍然设法使他们的代码工作。
    尽管没有任何API文档或保证，但通常的情况是，如果检查<code>Collection&lt；String&gt；<code>是否包含<code>foo<code>，
    则用于执行等式检查的equals参数方法(例如，<code>foo<code>类的equals方法)
    </p>
     ]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES">
    <ShortDescription>集合不应包含自身</ShortDescription>
<LongDescription>集合不应在调用{2.givenClass}中包含自身</LongDescription>
    <Details>
     <![CDATA[
     <p> 对泛型集合的方法的调用只有在集合包含自身时才有意义(例如，如果<code>s.containers(S)<code>为true)。
     这不太可能是真的，如果它是真的，将会导致问题(例如散列码的计算导致无限递归)。可能是作为参数传递的值错误
    </p>
     ]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_VACUOUS_SELF_COLLECTION_CALL">
    <ShortDescription>对集合的空洞调用</ShortDescription>
<LongDescription>对于任何集合c，调用c.{2.name}(C)都没有意义</LongDescription>
    <Details>
     <![CDATA[
     <p> 此呼叫没有意义。对于任何集合<code>c<code>，调用<code>c.tainsAll(C)<code>应该始终为true，而<code>c.retainAll(C)<code>应该没有任何效果
    </p>
     ]]>
    </Details>
  </BugPattern>
  <BugPattern type="PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS">
    <ShortDescription>不要在迭代器中重用Entry对象</ShortDescription>
<LongDescription>{0}既是Iterator又是Map.Entry</LongDescription>
    <Details>
     <![CDATA[
     <p> 允许entrySet()方法返回基础Map的视图，其中有Iterator和Map.Entry。
     这个聪明的想法在几个Map实现中被使用，但是引入了令人讨厌的编码错误的可能性。
     如果map<code>m<code>为entrySet返回这样的迭代器，则<code>c.addAll(m.entrySet()<code>将出现严重错误。
     OpenJDK 1.7中的所有Map实现都已重写以避免这种情况，您应该这样做
    </p>
     ]]>
    </Details>
  </BugPattern>
  <BugPattern type="DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS">
    <ShortDescription>由于条目对象的重用，添加条目集的元素可能会失败</ShortDescription>
<LongDescription>由于在{1}中重复使用{2.simpleClass}.Entry对象，添加条目集的元素可能会失败</LongDescription>
    <Details>
     <![CDATA[
     <p> 允许entrySet()方法返回底层Map的视图，其中单个Entry对象在迭代期间被重用并返回。
     从Java1.6开始，IdentityHashMap和EnumMap都这样做了。当在这样的Map中迭代时，条目值仅在您前进到下一次迭代之前有效。
     例如，如果您试图将这样的entrySet传递给addAll方法，事情就会变得非常糟糕
    </p>
     ]]>
    </Details>
  </BugPattern>

  <BugPattern type="DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION">
    <ShortDescription>不使用removeAll清除集合</ShortDescription>
<LongDescription>removeAll用于清除{1}中的集合</LongDescription>
    <Details>
     <![CDATA[
     <p> 如果要从集合中删除所有元素<code>c<code>，请使用<code>c.clear<code>，而不是<code>c.removeAll(C)<code>。
     调用<code>c.removeAll(C)<code>清除集合不太清楚，容易出现键入错误，效率较低，并且对于某些集合，可能引发<code>ConcurrentModificationException<code>
    </p>
     ]]>
    </Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_CALENDAR_INSTANCE">
    <ShortDescription>静态日历字段</ShortDescription>
<LongDescription>{1}是java.util.Calendar类型的静态字段，不是线程安全的</LongDescription>
    <Details>
<![CDATA[
<p>即使JavaDoc没有包含它的提示，日历对于多线程使用本质上也是不安全的。
在没有正确同步的情况下跨线程边界共享单个实例将导致应用程序的不稳定行为。
1.4以下的问题似乎比Java 5更少出现，你可能会在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate（）中看到随机的ArrayIndexOutOfBoundsExceptions或IndexOutOfBoundsExceptions。.</p>
<p>您可能还会遇到序列化问题。</p>
<p>建议使用实例字段。</p>
<p>登陆查找更多信息： <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579">Sun Bug #6231579</a>
和 <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997">Sun Bug #6178997</a>.</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE">
 <ShortDescription>调用静态日历</ShortDescription>
<LongDescription>调用{1}中静态java.util.Calendar的方法</LongDescription>
    <Details>
<![CDATA[
<p>即使JavaDoc没有包含它的提示，日历对于多线程使用本质上也是不安全的。
检测器找到了一个通过静态字段获得的Calendar实例的调用。 这看起来很可疑。</p>
<p>查找更多信息： <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579">Sun Bug #6231579</a>
and <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997">Sun Bug #6178997</a>.</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE">
    <ShortDescription>静态日期格式</ShortDescription>
<LongDescription>{1}是java.text.DateFormat类型的静态字段，它不是线程安全的</LongDescription>
    <Details>
<![CDATA[
<p>正如JavaDoc所述，DateFormats对于多线程使用本质上是不安全的。
在没有正确同步的情况下跨线程边界共享单个实例将导致应用程序的不稳定行为。</p>
<p>您可能还会遇到序列化问题</p>
<p>建议使用实例字段.</p>
<p>查找更多信息： <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579">Sun Bug #6231579</a>
and <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997">Sun Bug #6178997</a>.</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE">
<ShortDescription>调用静态DateFormat</ShortDescription>
<LongDescription>调用{1}中静态java.text.DateFormat的方法</LongDescription>
    <Details>
<![CDATA[
<p>正如JavaDoc所述，DateFormats对于多线程使用本质上是不安全的。
检测器找到了一个通过静态字段获得的DateFormat实例的调用。 这看起来很可疑。</p>
<p>查看更多信息： <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6231579">Sun Bug #6231579</a>
and <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6178997">Sun Bug #6178997</a>.</p>
]]>
</Details>
  </BugPattern>
  <BugPattern type="TQ_COMPARING_VALUES_WITH_INCOMPATIBLE_TYPE_QUALIFIERS">
    <ShortDescription>将值与不兼容的类型限定符进行比较</ShortDescription>
<LongDescription>将注释为具有类型限定符{2.simpleName}的值与从不具有该限定符的值进行相等比较</LongDescription>
    <Details>
      <![CDATA[
        <p>
        将指定为携带类型限定符注释的值与从未包含该限定符的值进行比较
        </p>

        <p>
        准确地说，用指定When=Always的类型限定符注释的值与相同类型限定符指定When=Never的值进行比较
        </p>

        <p>
        例如，假设@NonNegative是类型限定符annotation@负(when=When.NEVER)的昵称。以下代码将生成此警告，因为return语句需要@NonNegative值，但接收的值被标记为@Negative。
        </p>
        <blockquote>
<pre>
public boolean example(@Negative Integer value1, @NonNegative Integer value2) {
    return value1.equals(value2);
}
</pre>
        </blockquote>
      ]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED">
    <ShortDescription>注释为携带类型限定符的值，在需要不包含该限定符的值的情况下使用</ShortDescription>
<LongDescription>批注为携带类型限定符{2.simpleName}的值，在需要不包含该限定符的值时使用</LongDescription>n>
    <Details>
      <![CDATA[
        <p>
        指定为携带类型限定符批注的值在要求该值不包含该批注的一个或多个位置中使用
        </p>

        <p>
        更准确地说，用指定When=Always的类型限定符注释的值保证达到使用或使用相同类型限定符指定When=Never的地方
        </p>

        <p>
        例如，假设@NonNegative是类型限定符annotation@负(when=When.NEVER)的昵称。
        以下代码将生成此警告，
        因为return语句需要@NonNegative值，但接收的值被标记为@Negative。
        </p>
        <blockquote>
<pre>
public @NonNegative Integer example(@Negative Integer value) {
    return value;
}
</pre>
        </blockquote>
      ]]>
    </Details>
  </BugPattern>


  <BugPattern type="TQ_UNKNOWN_VALUE_USED_WHERE_ALWAYS_STRICTLY_REQUIRED">
    <ShortDescription>不带类型限定符的值，在要求值具有该限定符的情况下使用</ShortDescription>
<LongDescription>不带类型限定符的值用于需要{2.simpleName}批注的位置</LongDescription>
    <Details>
      <![CDATA[
        <p>
       某个值的使用方式要求该值为带有类型限定符的批注。类型限定符是严格的，因此该工具拒绝任何没有适当注释的值
        </p>

        <p>
        若要强制某个值具有严格批注，请定义一个标识函数，其中使用严格批注对返回值进行批注。这是将未注释的值转换为具有严格类型限定符注释的值的唯一方法。
        </p>

      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED">
    <ShortDescription>注释为从不携带类型限定符的值，在需要携带该限定符的值的情况下使用</ShortDescription>
<LongDescription>注释为从不携带类型限定符{2.simpleName}的值，在需要携带该限定符的值的情况下使用</LongDescription>
    <Details>
      <![CDATA[
        <p>
        定为不携带类型限定符批注的值保证在要求该值包含该批注的一个或多个位置中使用。
        </p>

        <p>
       更准确地说，用指定When=Never的类型限定符注释的值保证达到使用或使用相同类型限定符指定When=Always的地方.
        </p>

        <p>
        TODO: example
        </p>
      ]]>
    </Details>
  </BugPattern>




  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK">
   <ShortDescription>可能不包含类型限定符的值总是以需要该类型限定符的方式使用</ShortDescription>
<LongDescription>可能不包含{2.simpleName}批注的值始终以需要该类型限定符的方式使用</LongDescription>
    <Details>
      <![CDATA[
      <p>
      注释为可能的值不是由类型限定符表示的值的实例，并且该值保证以需要由该类型限定符表示的值的方式使用
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK">
   <ShortDescription>可能带有类型限定符的值总是以禁止其拥有该类型限定符的方式使用</ShortDescription>
<LongDescription>可能带有{2.simpleName}批注的值始终以禁止其具有该类型限定符的方式使用</LongDescription>
    <Details>
      <![CDATA[
      <p>
     注释为可能性的值是由类型限定符表示的值的实例，并且该值保证以禁止由该类型限定符表示的值的方式使用
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK">
    <ShortDescription>值需要没有类型限定符，但标记为未知</ShortDescription>
<LongDescription>
值要求永远不是{2.simpleName}，但对于{2.simpleName}显式批注为UNKNOWN
</LongDescription>
    <Details>
      <![CDATA[
      <p>
      值的使用方式要求它永远不是由类型限定符表示的值，但有一个显式注释声明不知道该值在哪里被禁止使用该类型限定符。用法或注释不正确
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK">
    <ShortDescription>需要具有类型限定符但标记为未知的值</ShortDescription>
<LongDescription>值必须始终为{2.simpleName}，但对于{2.simpleName}显式批注为未知</LongDescription>
    <Details>
      <![CDATA[
      <p>
      值的使用方式要求它始终是由类型限定符表示的值，但有一个显式注释声明不知道该值在哪里需要具有该类型限定符。用法或注释不正确
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="IO_APPENDING_TO_OBJECT_OUTPUT_STREAM">
    <ShortDescription>试图追加到对象输出流的尝试失败</ShortDescription>
<LongDescription>无法尝试追加到{1}中的对象输出流</LongDescription>
    <Details>
      <![CDATA[
      <p>
     此代码以追加模式打开文件，然后将结果包装在对象输出流中。这将不允许您附加到存储在文件中的现有对象输出流。如果希望能够附加到对象输出流，则需要保持对象输出流打开。
      </p>
      <p>在附加模式下打开文件并写入对象输出流的唯一情况是，在读取文件时计划以随机访问模式打开该文件，并查找到附加开始的字节偏移量
      </p>

      <p>
      TODO: example.
      </p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL">
    <ShortDescription>在getclass而不是类文字上进行同步</ShortDescription>
<LongDescription>在{1}中同步getclass而不是类文字</LongDescription>>
    <Details>
      <![CDATA[
      <p>
     此实例方法在<code> this.getClass（）</ code>上同步。 如果此类是子类，则子类将在子类的类对象上同步，这可能不是预期的。
      例如，请考虑来自java.awt.Label的此代码：</p>
     <pre>
     private static final String base = "label";
     private static int nameCounter = 0;
     String constructComponentName() {
        synchronized (getClass()) {
            return base + nameCounter++;
        }
     }
     </pre>
     <p><code> Label </ code>的子类不会在同一个子类上同步，从而产生datarace。
      相反，此代码应该在<code> Label.class </ code>上进行同步</p>
      <pre>
     private static final String base = "label";
     private static int nameCounter = 0;
     String constructComponentName() {
        synchronized (Label.class) {
            return base + nameCounter++;
        }
     }
     </pre>
      <p>Bug pattern contributed by Jason Mehrens</p>
      ]]>
    </Details>
  </BugPattern>
  <BugPattern type="OBL_UNSATISFIED_OBLIGATION">
   <ShortDescription>方法可能无法清理流或资源</ShortDescription>
<LongDescription>{1}可能无法清理{2}</LongDescription>
    <Details>
          <![CDATA[
          <p>
          此方法可能无法清除（关闭，处置）流，数据库对象或需要显式清除操作的其他资源。
          </p>

          <p>
          通常，如果方法打开流或其他资源，则该方法应使用try / finally块以确保在方法返回之前清除流或资源。
          </p>

          <p>
           这个bug模式基本上和 OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式，但基于不同的（并且希望更好）静态分析技术。
           我们感兴趣的是获得有关此bug模式的有用性的反馈。
           要发送反馈，请：
          </p>
          <ul>
            <li>send email to findbugs@cs.umd.edu</li>
            <li>file a bug report: <a href="http://findbugs.sourceforge.net/reportingBugs.html">http://findbugs.sourceforge.net/reportingBugs.html</a></li>
          </ul>

          <p>
          特别是，这种错误模式的假阳性抑制启发式方法尚未得到广泛调整，因此关于误报的报告对我们很有帮助。
          </p>

          <p>
          有关分析技术的描述，请参阅Weimer和Necula，<i>查找和防止运行时错误处理错误</ i>。
          </p>
          ]]>
      </Details>
  </BugPattern>




  <BugPattern type="OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE">
    <ShortDescription>方法在检查异常时可能无法清理流或资源</ShortDescription>
<LongDescription>检查异常时，{1}可能无法清理{2}</LongDescription>
    <Details>
          <![CDATA[
          <p>
          此方法可能无法清除（关闭，处置）流，数据库对象或需要显式清除操作的其他资源。
          </p>

          <p>
          通常，如果方法打开流或其他资源，
          该方法应使用try / finally块以确保在方法返回之前清除流或资源。
          </p>

          <p>
          此错误模式与OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式基本相同，但基于不同的（并且希望更好）静态分析技术。
          我们感兴趣的是获得有关此bug模式的有用性的反馈。
          要发送反馈，请：
          </p>
          <ul>
            <li>发邮件到 findbugs@cs.umd.edu</li>
            <li>提交错误报告: <a href="http://findbugs.sourceforge.net/reportingBugs.html">http://findbugs.sourceforge.net/reportingBugs.html</a></li>
          </ul>

          <p>
          特别是，这种错误模式的假阳性抑制启发式方法尚未得到广泛调整，因此关于误报的报告对我们很有帮助。
          </p>

          <p>
          有关分析技术的描述，请参阅Weimer和Necula，<i>查找和防止运行时错误处理错误</ i>。
          </p>
          ]]>
      </Details>
  </BugPattern>















  <BugPattern type="FB_UNEXPECTED_WARNING">
    <ShortDescription>意外的来自FindBugs的意外警告</ShortDescription>
<LongDescription>{1}中意外的{2}FindBugs警告</LongDescription>
    <Details>
          <![CDATA[
          <p>FindBugs生成了一个警告，根据@NoWarning注释，该警告是意外的或不希望的</p>
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="FB_MISSING_EXPECTED_WARNING">
    <ShortDescription>缺少来自FindBugs的预期或期望警告</ShortDescription>
<LongDescription>{1}中缺少预期或预期的{2}FindBugs警告</LongDescription>
    <Details>
          <![CDATA[
          <p>FindBugs未生成根据@ExpectedWarning注释的预期或期望的警告</p>
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED">
    <ShortDescription>忽略putIfAbsend的返回值，传递给putIfAbsend的值重复使用</ShortDescription>
<LongDescription>putIfAbsend的返回值被忽略，但{4}在{1}中重复使用</LongDescription>
    <Details>
          <![CDATA[
        <code>putIfAbsend<code>方法通常用于确保单个值与给定的键相关联(如果不存在则PUT成功的第一个值)。
        如果忽略返回值并保留对传入的值的引用，则可能会保留与映射中的键关联的值以外的值。
        如果你使用的是哪一个很重要，而你使用的是没有存储在地图中的那个，那么你的程序将会不正确地运行
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE">
    <ShortDescription>由于OpenJDK中的弱引用而可能丢失的记录器更改</ShortDescription>
<LongDescription>对记录器的更改可能会在{1}中丢失</LongDescription>
    <Details>
          <![CDATA[
<p>OpenJDK introduces a potential incompatibility.
 特别是，java.util.logging.Logger行为已更改。 它现在在内部使用弱引用，而不是使用强引用。 
 这是一个合理的改变，但不幸的是一些代码依赖于旧的行为 - 当更改记录器配置时，它只是删除了记录器引用。 
 这意味着垃圾收集器可以自由回收该内存，这意味着记录器配置丢失。 例如，
consider:
</p>

<pre>public static void initLogging() throws Exception {
 Logger logger = Logger.getLogger("edu.umd.cs");
 logger.addHandler(new FileHandler()); // call to change logger configuration
 logger.setUseParentHandlers(false); // another call to change logger configuration
}</pre>

<p>记录器引用在方法结束时丢失（它不会转义方法），因此如果在调用initLogging之后有一个垃圾收集周期，则记录器配置将丢失（因为Logger仅保留弱引用）.</p>

<pre>public static void main(String[] args) throws Exception {
 initLogging(); // adds a file handler to the logger
 System.gc(); // logger configuration lost
 Logger.getLogger("edu.umd.cs").info("Some message"); // this isn't logged to the file as expected
}</pre>
<p><em>Ulf Ochsenfahrt and Eric Fellheimer</em></p>
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION">
    <ShortDescription>对并发抽象的调用序列可能不是原子的</ShortDescription>
<LongDescription>对{2}的调用序列在{1}中不能是原子的</LongDescription>
    <Details>
          <![CDATA[
        <p>此代码包含对并发抽象(如并发哈希图)的一系列调用。这些调用将不会自动执行
          ]]>
      </Details>
  </BugPattern>
  <BugPattern type="DM_DEFAULT_ENCODING">
    <ShortDescription>依赖于默认编码</ShortDescription>
<LongDescription>在{1}中找到对默认编码的依赖：{2}</LongDescription>
    <Details>
<![CDATA[
<p> 找到了对将执行字节到字符串(或字符串到字节)转换的方法的调用，并将假定默认平台编码是合适的。
这将导致应用程序行为在不同平台之间发生变化。使用替代API并显式指定字符集名称或字符集对象  </p>
]]>
      </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_RELAXING_ANNOTATION">
    <ShortDescription>方法收紧了参数上的空值批注</ShortDescription>
<LongDescription>方法{1}重写nullness批注，放松祖先方法对参数的要求。</LongDescription>
    <Details>
        <![CDATA[<p>
        方法应始终实现其重写的方法的协定。因此，如果方法采用标记为@Nullable的参数，则不应使用该参数为@Nonnull的方法覆盖子类中的该方法。
        这样做违反了该方法应该处理null参数的约定
        </p>]]>
    </Details>
  </BugPattern>
  <BugPattern type="NP_METHOD_PARAMETER_TIGHTENS_ANNOTATION">
    <ShortDescription>方法收紧了参数上的空值批注</ShortDescription>
<LongDescription>方法{1}以不兼容的方式重写参数{2}的空度批注</LongDescription>
    <Details>
        <![CDATA[<p>
        方法应始终实现其重写的方法的协定。
        因此，如果方法采用标记为@Nullable的参数，则不应使用该参数为@Nonnull的方法覆盖子类中的该方法。
        这样做违反了该方法应该处理null参数的约定
  
        </p>]]>
      </Details>
  </BugPattern>

  <BugPattern type="NP_METHOD_RETURN_RELAXING_ANNOTATION">
    <ShortDescription>方法松弛返回值上的空值批注</ShortDescription>
<LongDescription>方法{1}以不兼容的方式重写返回值nullness批注。</LongDescription>
    <Details>
        <![CDATA[<p>
        方法应始终实现其重写的方法的协定。
        因此，如果方法采用注释为返回@Nonnull值的方法，则不应使用注释为返回@Nullable或@CheckForNull值的方法覆盖子类中的该方法。
        这样做违反了该方法不应返回null的约定
        </p>]]>
      </Details>
  </BugPattern>
  <!--
  **********************************************************************
   BugCodes
  **********************************************************************
   -->
  <BugCode abbrev="FS">Format string problem</BugCode>
  <BugCode abbrev="SKIPPED">Analysis skipped</BugCode>
  <BugCode abbrev="IL">Infinite Loop</BugCode>
  <BugCode abbrev="VO">Use of volatile</BugCode>
  <BugCode abbrev="UI">Unsafe inheritance</BugCode>
  <BugCode abbrev="FL">Use of floating point precision</BugCode>
  <BugCode abbrev="TEST">Testing prototype and incomplete bug pattern</BugCode>
  <BugCode abbrev="IMSE">Dubious catching of IllegalMonitorStateException</BugCode>
  <BugCode abbrev="CN">Bad implementation of cloneable idiom</BugCode>
  <BugCode abbrev="CAA">Covariant array assignment</BugCode>
  <BugCode abbrev="AT">Possible atomicity violation</BugCode>
  <BugCode abbrev="FI">Incorrect use of finalizers</BugCode>
  <BugCode abbrev="ES">Checking String equality using == or !=</BugCode>
  <BugCode abbrev="ML">Synchronization on updated field (Mutable Lock)</BugCode>
  <BugCode abbrev="UG">Unsynchronized get method, synchronized set method</BugCode>
  <BugCode abbrev="IO">Input/Output problem</BugCode>
  <BugCode abbrev="IC">Initialization circularity</BugCode>
  <BugCode abbrev="SI">Suspicious static initializer</BugCode>
  <BugCode abbrev="MSF">Mutable servlet field</BugCode>
  <BugCode abbrev="IS">Inconsistent synchronization</BugCode>
  <BugCode abbrev="Eq">Problems with implementation of equals()</BugCode>
  <BugCode abbrev="Co">Problems with implementation of compareTo()</BugCode>
  <BugCode abbrev="HE">Equal objects must have equal hashcodes</BugCode>
  <BugCode abbrev="AM">API misuse</BugCode>
  <BugCode abbrev="Dm">Dubious method used</BugCode>
  <BugCode abbrev="Bx">Questionable Boxing of primitive value</BugCode>
  <BugCode abbrev="UR">Uninitialized read of field in constructor</BugCode>
  <BugCode abbrev="RR">Method ignores results of InputStream.read()</BugCode>
  <BugCode abbrev="NN">Naked notify</BugCode>
  <BugCode abbrev="UW">Unconditional wait</BugCode>
  <BugCode abbrev="SP">Method spins on field</BugCode>
  <BugCode abbrev="DC">Double check pattern</BugCode>
  <BugCode abbrev="Wa">Wait not in loop</BugCode>
  <BugCode abbrev="No">Using notify() rather than notifyAll()</BugCode>
  <BugCode abbrev="DE">Dropped or ignored exception</BugCode>
  <BugCode abbrev="Ru">Method invokes run()</BugCode>
  <BugCode abbrev="It">Incorrect definition of Iterator</BugCode>
  <BugCode abbrev="SnVI">Serializable class with no Version ID</BugCode>
  <BugCode abbrev="Se">Incorrect definition of Serializable class</BugCode>
  <BugCode abbrev="WS">Class's writeObject() method is synchronized but nothing else is</BugCode>
  <BugCode abbrev="RS">Class's readObject() method is synchronized</BugCode>
  <BugCode abbrev="SC">Constructor invokes Thread.start()</BugCode>
  <BugCode abbrev="MS">Mutable static field</BugCode>
  <BugCode abbrev="ME">Mutable enum field</BugCode>
  <BugCode abbrev="EI">Method returning array may expose internal representation</BugCode>
  <BugCode abbrev="Nm">Confusing method name</BugCode>
  <BugCode abbrev="SS">Unread field should be static</BugCode>
  <BugCode abbrev="UuF">Unused field</BugCode>
  <BugCode abbrev="UrF">Unread field</BugCode>
  <BugCode abbrev="UwF">Unwritten field</BugCode>
  <BugCode abbrev="SIC">Inner class could be made static</BugCode>
  <BugCode abbrev="TLW">Wait with two locks held</BugCode>
  <BugCode abbrev="RANGE">Range checks</BugCode>
  <BugCode abbrev="RV">Bad use of return value from method</BugCode>
  <BugCode abbrev="LG">Logger problem</BugCode>
  <BugCode abbrev="IA">Ambiguous invocation</BugCode>
  <BugCode abbrev="HSC">Huge String constants</BugCode>
  <BugCode abbrev="HRS">HTTP Response splitting vulnerability</BugCode>
  <BugCode abbrev="PT">Path traversal</BugCode>
  <BugCode abbrev="XSS">Cross site scripting vulnerability</BugCode>
  <BugCode abbrev="NP">Null pointer dereference</BugCode>
  <BugCode abbrev="NOISE">Bogus random warning</BugCode>
  <BugCode abbrev="RpC">Repeated conditional test</BugCode>
  <BugCode abbrev="OS">Stream not closed on all paths</BugCode>
  <BugCode abbrev="PZLA">Prefer zero length arrays to null to indicate no results</BugCode>
  <BugCode abbrev="UCF">Useless control flow</BugCode>
  <BugCode abbrev="RCN">Redundant comparison to null</BugCode>
  <BugCode abbrev="UL">Lock not released on all paths</BugCode>
  <BugCode abbrev="RC">Questionable use of reference equality rather than calling equals</BugCode>
  <BugCode abbrev="EC">Comparing incompatible types for equality</BugCode>
  <BugCode abbrev="MWN">Mismatched wait() or notify()</BugCode>
  <BugCode abbrev="SA">Useless self-operation</BugCode>
  <BugCode abbrev="INT">Suspicious integer expression</BugCode>
  <BugCode abbrev="BIT">Suspicious bitwise logical expression</BugCode>
  <BugCode abbrev="LI">Unsynchronized Lazy Initialization</BugCode>
  <BugCode abbrev="JLM">Synchronization on java.util.concurrent objects</BugCode>
  <BugCode abbrev="UPM">Private method is never called</BugCode>
  <BugCode abbrev="UMAC">Uncallable method of anonymous class</BugCode>
  <BugCode abbrev="EI2">Storing reference to mutable object</BugCode>
  <BugCode abbrev="NS">Suspicious use of non-short-circuit boolean operator</BugCode>
  <BugCode abbrev="ODR">Database resource not closed on all paths</BugCode>
  <BugCode abbrev="SBSC">String concatenation in loop using + operator</BugCode>
  <BugCode abbrev="IIL">Inefficient code which can be moved outside of the loop</BugCode>
  <BugCode abbrev="IIO">Inefficient use of String.indexOf(String) or String.lastIndexOf(String)</BugCode>
  <BugCode abbrev="ITA">Inefficient use of collection.toArray(new Foo[0])</BugCode>
  <BugCode abbrev="SW">Swing coding rules</BugCode>
  <BugCode abbrev="IJU">Improperly implemented JUnit TestCase</BugCode>
  <BugCode abbrev="BOA">Badly Overridden Adapter</BugCode>
  <BugCode abbrev="SF">Switch case falls through</BugCode>
  <BugCode abbrev="SIO">Superfluous instanceof</BugCode>
  <BugCode abbrev="BAC">Bad Applet Constructor</BugCode>
  <BugCode abbrev="UOE">Use Object Equals</BugCode>
  <BugCode abbrev="STI">Suspicious Thread Interrupted</BugCode>
  <BugCode abbrev="DLS">Dead local store</BugCode>
  <BugCode abbrev="IP">Ignored parameter</BugCode>
  <BugCode abbrev="MF">Masked Field</BugCode>
  <BugCode abbrev="WMI">Inefficient Map Iterator</BugCode>
  <BugCode abbrev="ISC">Instantiated Static Class</BugCode>
  <BugCode abbrev="REC">RuntimeException capture</BugCode>
  <BugCode abbrev="FE">Test for floating point equality</BugCode>
  <BugCode abbrev="UM">Unnecessary Math on constants</BugCode>
  <BugCode abbrev="UC">Useless code</BugCode>
  <BugCode abbrev="CNT">Rough value of known constant</BugCode>
  <BugCode abbrev="CD">Circular Dependencies</BugCode>
  <BugCode abbrev="RI">Redundant Interfaces</BugCode>
  <BugCode abbrev="MTIA">Multithreaded Instance Access</BugCode>
  <BugCode abbrev="PS">Public Semaphores</BugCode>
  <BugCode abbrev="BSHIFT">Bad shift</BugCode>
  <BugCode abbrev="ICAST">Casting from integer values</BugCode>
  <BugCode abbrev="RE">Regular expressions</BugCode>
  <BugCode abbrev="SQL">Potential SQL Problem</BugCode>
  <BugCode abbrev="WL">Possible locking on wrong object</BugCode>
  <BugCode abbrev="ESync">Empty Synchronized blocks</BugCode>
  <BugCode abbrev="QF">Questionable for loops</BugCode>
  <BugCode abbrev="VA">Var arg problems</BugCode>
  <BugCode abbrev="BC">Bad casts of object references</BugCode>
  <BugCode abbrev="IM">Questionable integer math</BugCode>
  <BugCode abbrev="ST">Misuse of static fields</BugCode>
  <BugCode abbrev="JCIP">Violation of net.jcip annotations</BugCode>
  <BugCode abbrev="USELESS_STRING">Useless/non-informative string generated</BugCode>
  <BugCode abbrev="DMI">Dubious method invocation</BugCode>
  <BugCode abbrev="PZ">Warning inspired by Josh Bloch's and Neal Gafter's Programming Puzzlers</BugCode>
  <BugCode abbrev="SWL">Sleep with lock held</BugCode>
  <BugCode abbrev="J2EE">J2EE error</BugCode>
  <BugCode abbrev="DB">Duplicate Branches</BugCode>
  <BugCode abbrev="IMA">Inefficient Member Access</BugCode>
  <BugCode abbrev="XFB">XML Factory Bypass</BugCode>
  <BugCode abbrev="USM">Useless Subclass Method</BugCode>
  <BugCode abbrev="CI">Confused Inheritance</BugCode>
  <BugCode abbrev="QBA">Questionable Boolean Assignment</BugCode>
  <BugCode abbrev="VR">Version compatibility issue</BugCode>
  <BugCode abbrev="DP">Use doPrivileged</BugCode>
  <BugCode abbrev="GC">Suspicious calls to generic collection methods</BugCode>
  <BugCode abbrev="STCAL">Static use of type Calendar or DateFormat</BugCode>
  <BugCode abbrev="TQ">Inconsistent use of type qualifier annotations</BugCode>
  <BugCode abbrev="OBL">Unsatisfied obligation to clean up stream or resource</BugCode>
  <BugCode abbrev="FB">FindBugs did not produce the expected warnings on a method</BugCode>
  <BugCode abbrev="DL">Unintended contention or possible deadlock due to locking on shared objects</BugCode>
</MessageCollection>
